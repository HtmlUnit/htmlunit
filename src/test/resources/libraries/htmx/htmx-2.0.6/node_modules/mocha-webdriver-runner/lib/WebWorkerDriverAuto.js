"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.runWorkerTestsAuto = void 0;
var RemoteCommon_1 = require("./RemoteCommon");
var treesync_1 = require("@zbigg/treesync");
var WebWorkerDriver_1 = require("./WebWorkerDriver");
function workerCode() {
    var MAGIC_TIMEOUT = 312345678;
    var DEFAULT_BOOTSTRAP_SCRIPTS = [
        "../node_modules/mocha/mocha.js",
        "../node_modules/mocha-webdriver-runner/dist/mocha-webdriver-client.js"
    ];
    function initialize(env) {
        var baseUrl = env.baseUrl || "";
        var bootstrapScripts = env.bootstrapScripts || DEFAULT_BOOTSTRAP_SCRIPTS;
        bootstrapScripts.forEach(function (scriptUrl) {
            self.importScripts(baseUrl + scriptUrl);
        });
        if (mocha === undefined) {
            self.postMessage({
                type: "err-aborted",
                message: "global object 'mocha' not available after bootstrap"
            });
        }
        if (MochaWebdriverClient === undefined) {
            self.postMessage({
                type: "err-aborted",
                message: "global object 'MochaWebdriverClient' not available after bootstrap"
            });
        }
        MochaWebdriverClient.installGlobalErrorHandlers();
        mocha.setup({
            ui: "bdd",
            reporter: MochaWebdriverClient.Reporter
        });
        mocha.timeout(MAGIC_TIMEOUT);
        var tests = env.tests || [];
        tests.forEach(function (testUrl) {
            self.importScripts(baseUrl + testUrl);
        });
        mocha.checkLeaks();
        mocha.run(function () {
            self.postMessage({ type: "mocha-finished" });
        });
    }
    var onMessage = function (event) {
        var message = event.data;
        try {
            if (message.type === "boostrap-worker") {
                initialize(message);
                self.removeEventListener('message', onMessage);
            }
            else {
                console.log("unknown message received", message);
            }
        }
        catch (error) {
            self.postMessage({
                type: "err-unhandled-exception",
                message: "[worker] " + error.message,
                // manually serialized error
                error: {
                    root: {
                        type: 'error',
                        value: {
                            message: error.message,
                            stack: error.stack
                        }
                    },
                    objects: {}
                }
            });
        }
    };
    self.addEventListener('message', onMessage);
    self.postMessage({ type: "worker-ready-for-bootstrap" });
}
/**
 * Run `tests` under Mocha in WebWorker.
 *
 * All test events are forwarded using [[emitPageEvent]] to node driver.
 *
 * @param options urls of test scripts or [[WorkerTestAutoOptions]].
 */
function runWorkerTestsAuto(options) {
    var actualOptions = Array.isArray(options)
        ? {
            tests: options
        }
        : options;
    RemoteCommon_1.installGlobalErrorHandlers();
    RemoteCommon_1.installConsoleLogForwarder();
    return new Promise(function (resolve, reject) {
        var workerScript = "\n            " + workerCode + "\n            workerCode();\n        ";
        var workerScriptBlob = new Blob([workerScript], { type: "application/javascript" });
        var workerScriptUrl = URL.createObjectURL(workerScriptBlob);
        var worker = new Worker(workerScriptUrl);
        var firstMessageReceived = false;
        var bootstraped = false;
        function end() {
            worker.terminate();
        }
        function emitCommandToWorker(command) {
            worker.postMessage(command);
        }
        var onWorkerError = function (event) {
            if (!firstMessageReceived || !bootstraped) {
                worker.terminate();
                var message = firstMessageReceived
                    ? "unable to boostrap Worker"
                    : "unable to start Worker";
                RemoteCommon_1.runnerBackChannel.postMessage({
                    type: "err-aborted",
                    message: message,
                    error: treesync_1.buildMessage(event.error || event.message)
                });
                reject(new Error(message));
            }
            else {
                RemoteCommon_1.runnerBackChannel.postMessage({
                    type: "err-unhandled-exception",
                    message: "Unhandled error in Worker context.",
                    error: treesync_1.buildMessage(event.error || event.message)
                });
            }
        };
        var onWorkerMessage = function (event) {
            if (!firstMessageReceived) {
                firstMessageReceived = true;
            }
            var message = event.data;
            //
            // TODO:
            //   This protocol (worker-ready-for-bootstrap&boostrap-worker) can be generalized and
            //   used "driver->browser" auto scheme too so client doesn't have to create html and
            //   `mocha-webdriver-runner` can be serve files too!.
            //
            if (message.type === "worker-ready-for-bootstrap") {
                emitCommandToWorker({
                    type: "boostrap-worker",
                    baseUrl: baseUrl(document.baseURI),
                    bootstrapScripts: actualOptions.bootstrapScripts,
                    tests: actualOptions.tests
                });
                worker.removeEventListener("error", onWorkerError);
                worker.removeEventListener("message", onWorkerMessage);
                // pass control to normal worker handler
                WebWorkerDriver_1.addWorkerSource(worker);
            }
            else if (message.type === "mocha-finished") {
                end();
                resolve();
            }
        };
        worker.addEventListener("error", onWorkerError);
        worker.addEventListener("message", onWorkerMessage);
    });
}
exports.runWorkerTestsAuto = runWorkerTestsAuto;
function baseUrl(url) {
    var idx = url.lastIndexOf("/");
    if (idx === -1) {
        return "./";
    }
    else {
        return url.substring(0, idx + 1);
    }
}
