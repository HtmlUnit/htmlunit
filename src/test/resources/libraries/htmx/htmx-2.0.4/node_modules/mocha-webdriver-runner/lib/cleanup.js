"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function safeCallbackToPromise(f) {
    try {
        return Promise.resolve(f());
    }
    catch (error) {
        return Promise.reject(error);
    }
}
exports.safeCallbackToPromise = safeCallbackToPromise;
function throwExpr(error) {
    throw error;
}
function getCleanerCallback(entry) {
    if (typeof entry === "function") {
        return entry;
    }
    var e = entry;
    return (e.dispose ||
        e.close ||
        e.destroy ||
        throwExpr(new Error("withCleanup: invalid disposable"))).bind(entry);
}
function withCleanup(f) {
    var cleanupBegan = false;
    var cleaners = [];
    function addCleaner(cleaner) {
        if (cleanupBegan) {
            throw new Error("withCleanup: cannot register new cleanup: cleanup already began");
        }
        cleaners.push(getCleanerCallback(cleaner));
        return cleaner;
    }
    return new Promise(function (resolve, reject) {
        var result;
        var firstError;
        function startCleanup() {
            cleanupBegan = true;
            cleanupCallback(cleaners.length - 1);
        }
        function cleanupCallback(cleanerIndex) {
            if (cleanerIndex < 0) {
                if (firstError !== undefined) {
                    reject(firstError);
                }
                else {
                    resolve(result);
                }
                return;
            }
            var cleaner = cleaners[cleanerIndex];
            safeCallbackToPromise(cleaner)
                .then(function () {
                cleanupCallback(cleanerIndex - 1);
            })
                .catch(function (error) {
                // handle errors in original callback
                if (firstError !== undefined) {
                    firstError = error;
                }
                else {
                    console.error("withCleanup: ignored intermediate error: " + error, error);
                }
                cleanupCallback(cleanerIndex - 1);
            });
        }
        safeCallbackToPromise(function () { return f(addCleaner); })
            .then(function (r) {
            result = r;
            startCleanup();
        })
            .catch(function (e) {
            // handle errors in original callback
            firstError = e;
            startCleanup();
        });
    });
}
exports.withCleanup = withCleanup;
function withCleanupSync(f) {
    var cleanupBegan = false;
    var cleaners = [];
    function addCleaner(cleaner) {
        if (cleanupBegan) {
            throw new Error("withCleanupSync: cannot register new cleaner: cleanup already began");
        }
        cleaners.push(cleaner);
    }
    function cleanup(error) {
        cleanupBegan = true;
        var firstError = error;
        for (var cleanerIndex = cleaners.length - 1; cleanerIndex > 0; --cleanerIndex) {
            var cleaner = cleaners[cleanerIndex];
            try {
                cleaner();
            }
            catch (error) {
                if (firstError === undefined) {
                    firstError = error;
                }
                else {
                    console.error("withCleanupSync: ignored intermediate error: " + error, error);
                }
            }
        }
        if (firstError !== undefined) {
            throw firstError;
        }
    }
    try {
        var r = f(addCleaner);
        cleanup();
        return r;
    }
    catch (error) {
        cleanup(error);
        // not sure, why needed if cleanup(err) returns never
        return undefined;
    }
}
exports.withCleanupSync = withCleanupSync;
