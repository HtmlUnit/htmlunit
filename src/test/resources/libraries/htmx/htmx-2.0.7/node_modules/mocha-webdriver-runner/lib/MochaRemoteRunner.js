"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.runRemoteMochaTest = void 0;
var mocha = require("mocha");
var suite_synchronizer_1 = require("./suite-synchronizer");
var treesync_1 = require("@zbigg/treesync");
function runRemoteMochaTest(messagePort, options) {
    return new Promise(function (resolve, reject) {
        var result = {
            success: false,
            dumpedGlobals: {}
        };
        var captureConsoleLog = options.captureConsoleLog !== false;
        var reporterConstructor = getReporterConstructor(options);
        var synchronizer = suite_synchronizer_1.createMochaStateSynchronizer();
        var runner;
        var reporter;
        var started = false;
        function processRunnerEvent(event) {
            if (event.type === "start") {
                runner = new mocha.Runner(event.suite, options.delay === true);
                runner.stats = {
                    suites: 0,
                    tests: 0,
                    passes: 0,
                    pending: 0,
                    failures: 0
                };
                reporter = new reporterConstructor(runner, options);
                runner.emit("start");
                started = true;
            }
            else if (event.type === "suite") {
                runner.emit("suite", event.suite);
            }
            else if (event.type === "suite end") {
                runner.emit("suite end", event.suite);
            }
            else if (event.type === "test") {
                runner.emit("test", event.test);
            }
            else if (event.type === "test end") {
                runner.emit("test end", event.test);
            }
            else if (event.type === "pass") {
                runner.emit("pass", event.test);
            }
            else if (event.type === "fail") {
                runner.emit("fail", event.test, event.err);
            }
            else if (event.type === "end") {
                Object.assign(runner.stats, event.stats || {});
                runner.emit("end");
                end(event.failures || 0);
            }
            else if (event.type === "pending") {
                runner.emit("pending", event.test);
            }
            else {
                console.error("#runRemoteMochaTest: invalid event received from page", event.type || event);
            }
        }
        function onMessage(event) {
            var message = event.data;
            if (!message) {
                console.log("#runRemoteMochaTest: received empty event");
            }
            switch (message.type) {
                case "mocha-ready":
                    if (options.clientWaitsForOptions !== false) {
                        messagePort.postMessage({
                            type: "mocha-run",
                            mochaOptions: {
                                grep: options.grep,
                                captureConsoleLog: captureConsoleLog,
                                timeout: options.timeout,
                                globalsToSave: options.globalsToSave
                            }
                        });
                    }
                    break;
                case "log":
                    if (!captureConsoleLog) {
                        return;
                    }
                    var args = ["[browser] " + message.level + ":"].concat(treesync_1.decodeMessage(message.args));
                    console[message.level].apply(console, args);
                    break;
                case "var-dump":
                    var value = treesync_1.decodeMessage(message.value);
                    result.dumpedGlobals[message.name] = value;
                    break;
                case "err-unhandled-exception":
                    {
                        console.error(message.message);
                        var error = treesync_1.decodeMessage(message.error);
                        if (error) {
                            console.error(error);
                        }
                    }
                    break;
                case "mocha-runner-event":
                    processRunnerEvent(synchronizer.decodePacket(message.event));
                    break;
                case "err-aborted":
                    {
                        var error = treesync_1.decodeMessage(message.error);
                        if (error) {
                            console.error(error);
                        }
                        cleanup();
                        reject(new Error(message.message));
                    }
                    break;
            }
        }
        function onErrorEvent(errorEvent) {
            var error = errorEvent.error || "missing error information";
            console.error("[browser] Unhandled exception: " + error, error);
            if (!started) {
                reject(new Error("#runRemoteMochaTest: Unhandled exeption in remote context before test start: " + error));
            }
        }
        function start() {
            messagePort.addEventListener("message", onMessage);
            messagePort.addEventListener("error", onErrorEvent);
        }
        function cleanup() {
            messagePort.removeEventListener("message", onMessage);
            messagePort.removeEventListener("error", onErrorEvent);
        }
        function end(failures) {
            cleanup();
            // If reporter has 'done', then we shall call it (mochawesome relies on this).
            var reporterDone = reporter && reporter.done;
            if (typeof reporterDone === "function") {
                reporterDone.call(reporter, failures, function () {
                    result.success = failures === 0;
                    resolve(result);
                });
            }
            else {
                result.success = failures === 0;
                resolve(result);
            }
        }
        start();
    });
}
exports.runRemoteMochaTest = runRemoteMochaTest;
function getReporterConstructor(options) {
    var reporterDef = options.reporter || "spec";
    if (typeof reporterDef === "string") {
        var mochaBuiltinReporters = mocha.reporters;
        var builtinReporter = mochaBuiltinReporters[reporterDef];
        if (typeof builtinReporter === "function") {
            return builtinReporter;
        }
        var customReporter = require(reporterDef);
        if (typeof customReporter === "function") {
            return customReporter;
        }
    }
    if (typeof reporterDef === "function") {
        return reporterDef;
    }
    else {
        throw new Error("unknown reporter: " + reporterDef);
    }
}
