"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.installGlobalErrorHandlers = exports.installConsoleLogForwarder = exports.overrideDefaultMagicTimeout = exports.applyMochaOptions = exports.runnerBackChannel = exports.inWebWorkerContext = exports.MAGIC_TIMEOUT = exports.currentOptions = void 0;
var WebWorkerMessagePort_1 = require("./WebWorkerMessagePort");
var BrowserMessagePort_1 = require("./BrowserMessagePort");
var treesync_1 = require("@zbigg/treesync");
exports.currentOptions = {};
exports.MAGIC_TIMEOUT = 312345678;
function inWebWorkerContext() {
    return typeof self !== "undefined" && typeof self.importScripts !== "undefined";
}
exports.inWebWorkerContext = inWebWorkerContext;
exports.runnerBackChannel = inWebWorkerContext()
    ? new WebWorkerMessagePort_1.WebWorkerMessagePort()
    : new BrowserMessagePort_1.BrowserMessagePort();
function applyMochaOptions(mocha, options) {
    exports.currentOptions = __assign(__assign({}, exports.currentOptions), options);
    if (options.captureConsoleLog) {
        installConsoleLogForwarder();
    }
    if (options.checkLeaks !== undefined) {
        if (options.checkLeaks) {
            mocha.checkLeaks();
        }
        else {
            mocha.ignoreLeaks(true);
        }
    }
    if (options.globals !== undefined) {
        mocha.globals(options.globals);
    }
    if (options.grep) {
        mocha.grep(options.grep);
    }
    {
        var timeout = options.timeout !== undefined ? options.timeout : 2000;
        overrideDefaultMagicTimeout(mocha.suite, timeout);
        mocha.timeout(timeout);
    }
}
exports.applyMochaOptions = applyMochaOptions;
function overrideDefaultMagicTimeout(suite, timeout) {
    var overrideMagicTimeout = function (obj) {
        if (obj.timeout() === exports.MAGIC_TIMEOUT) {
            obj.timeout(timeout);
        }
    };
    overrideMagicTimeout(suite);
    suite.tests.forEach(overrideMagicTimeout);
    suite._beforeEach.forEach(overrideMagicTimeout);
    suite._beforeAll.forEach(overrideMagicTimeout);
    suite._afterEach.forEach(overrideMagicTimeout);
    suite._afterAll.forEach(overrideMagicTimeout);
    suite.suites.forEach(function (subSuite) {
        overrideDefaultMagicTimeout(subSuite, timeout);
    });
}
exports.overrideDefaultMagicTimeout = overrideDefaultMagicTimeout;
var consoleLogSenderInstalled = false;
/**
 * Hijack `console.*` to send all logs to parent through `runnerBackChannel`.
 */
function installConsoleLogForwarder() {
    if (consoleLogSenderInstalled) {
        return;
    }
    consoleLogSenderInstalled = true;
    var originalConsole = {
        log: console.log,
        info: console.info,
        warn: console.warn,
        error: console.error
    };
    function runnerLogForwarder(level) {
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            originalConsole[level].apply(console, args);
            exports.runnerBackChannel.postMessage({
                type: "log",
                level: level,
                args: treesync_1.buildMessage(args)
            });
        };
    }
    console.log = runnerLogForwarder("log");
    console.info = runnerLogForwarder("info");
    console.warn = runnerLogForwarder("warn");
    console.error = runnerLogForwarder("error");
}
exports.installConsoleLogForwarder = installConsoleLogForwarder;
var globalErrorHandlersInstalled = false;
function installGlobalErrorHandlers() {
    if (globalErrorHandlersInstalled) {
        return;
    }
    globalErrorHandlersInstalled = true;
    self.addEventListener("unhandledrejection", function (event) {
        exports.runnerBackChannel.postMessage({
            type: "err-unhandled-exception",
            message: "Unhandled rejection in Browser context.",
            error: treesync_1.buildMessage(event.reason)
        });
    });
    self.addEventListener("error", function (event) {
        exports.runnerBackChannel.postMessage({
            type: "err-unhandled-exception",
            message: "Unhandled error in Browser context.",
            error: treesync_1.buildMessage(event.error || event.message)
        });
    });
}
exports.installGlobalErrorHandlers = installGlobalErrorHandlers;
