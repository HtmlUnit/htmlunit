(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('mocha')) :
    typeof define === 'function' && define.amd ? define(['exports', 'mocha'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.MochaWebdriverClient = {}, global.Mocha));
}(this, (function (exports, mocha$1) { 'use strict';

    function _interopNamespace(e) {
        if (e && e.__esModule) return e;
        var n = Object.create(null);
        if (e) {
            Object.keys(e).forEach(function (k) {
                if (k !== 'default') {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () {
                            return e[k];
                        }
                    });
                }
            });
        }
        n['default'] = e;
        return Object.freeze(n);
    }

    var mocha__namespace = /*#__PURE__*/_interopNamespace(mocha$1);

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }

    // Copyright Joyent, Inc. and other Node contributors.

    var R = typeof Reflect === 'object' ? Reflect : null;
    var ReflectApply = R && typeof R.apply === 'function'
      ? R.apply
      : function ReflectApply(target, receiver, args) {
        return Function.prototype.apply.call(target, receiver, args);
      };

    var ReflectOwnKeys;
    if (R && typeof R.ownKeys === 'function') {
      ReflectOwnKeys = R.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys(target) {
        return Object.getOwnPropertyNames(target)
          .concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys(target) {
        return Object.getOwnPropertyNames(target);
      };
    }

    function ProcessEmitWarning(warning) {
      if (console && console.warn) console.warn(warning);
    }

    var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
      return value !== value;
    };

    function EventEmitter() {
      EventEmitter.init.call(this);
    }
    var events = EventEmitter;
    var once_1 = once;

    // Backwards-compat with node 0.10.x
    EventEmitter.EventEmitter = EventEmitter;

    EventEmitter.prototype._events = undefined;
    EventEmitter.prototype._eventsCount = 0;
    EventEmitter.prototype._maxListeners = undefined;

    // By default EventEmitters will print a warning if more than 10 listeners are
    // added to it. This is a useful default which helps finding memory leaks.
    var defaultMaxListeners = 10;

    function checkListener(listener) {
      if (typeof listener !== 'function') {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }

    Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
        }
        defaultMaxListeners = arg;
      }
    });

    EventEmitter.init = function() {

      if (this._events === undefined ||
          this._events === Object.getPrototypeOf(this)._events) {
        this._events = Object.create(null);
        this._eventsCount = 0;
      }

      this._maxListeners = this._maxListeners || undefined;
    };

    // Obviously not all Emitters should be limited to 10. This function allows
    // that to be increased. Set to zero for unlimited.
    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
      }
      this._maxListeners = n;
      return this;
    };

    function _getMaxListeners(that) {
      if (that._maxListeners === undefined)
        return EventEmitter.defaultMaxListeners;
      return that._maxListeners;
    }

    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };

    EventEmitter.prototype.emit = function emit(type) {
      var args = [];
      for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
      var doError = (type === 'error');

      var events = this._events;
      if (events !== undefined)
        doError = (doError && events.error === undefined);
      else if (!doError)
        return false;

      // If there is no 'error' event listener then throw.
      if (doError) {
        var er;
        if (args.length > 0)
          er = args[0];
        if (er instanceof Error) {
          // Note: The comments on the `throw` lines are intentional, they show
          // up in Node's output if this results in an unhandled exception.
          throw er; // Unhandled 'error' event
        }
        // At least give some kind of context to the user
        var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
        err.context = er;
        throw err; // Unhandled 'error' event
      }

      var handler = events[type];

      if (handler === undefined)
        return false;

      if (typeof handler === 'function') {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          ReflectApply(listeners[i], this, args);
      }

      return true;
    };

    function _addListener(target, type, listener, prepend) {
      var m;
      var events;
      var existing;

      checkListener(listener);

      events = target._events;
      if (events === undefined) {
        events = target._events = Object.create(null);
        target._eventsCount = 0;
      } else {
        // To avoid recursion in the case that type === "newListener"! Before
        // adding it to the listeners, first emit "newListener".
        if (events.newListener !== undefined) {
          target.emit('newListener', type,
                      listener.listener ? listener.listener : listener);

          // Re-assign `events` because a newListener handler could have caused the
          // this._events to be assigned to a new object
          events = target._events;
        }
        existing = events[type];
      }

      if (existing === undefined) {
        // Optimize the case of one listener. Don't need the extra array object.
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === 'function') {
          // Adding the second element, need to change to array.
          existing = events[type] =
            prepend ? [listener, existing] : [existing, listener];
          // If we've already got an array, just append.
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }

        // Check for listener leak
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
          existing.warned = true;
          // No error code for this since it is a Warning
          // eslint-disable-next-line no-restricted-syntax
          var w = new Error('Possible EventEmitter memory leak detected. ' +
                              existing.length + ' ' + String(type) + ' listeners ' +
                              'added. Use emitter.setMaxListeners() to ' +
                              'increase limit');
          w.name = 'MaxListenersExceededWarning';
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          ProcessEmitWarning(w);
        }
      }

      return target;
    }

    EventEmitter.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };

    EventEmitter.prototype.on = EventEmitter.prototype.addListener;

    EventEmitter.prototype.prependListener =
        function prependListener(type, listener) {
          return _addListener(this, type, listener, true);
        };

    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }

    function _onceWrap(target, type, listener) {
      var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }

    EventEmitter.prototype.once = function once(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };

    EventEmitter.prototype.prependOnceListener =
        function prependOnceListener(type, listener) {
          checkListener(listener);
          this.prependListener(type, _onceWrap(this, type, listener));
          return this;
        };

    // Emits a 'removeListener' event if and only if the listener was removed.
    EventEmitter.prototype.removeListener =
        function removeListener(type, listener) {
          var list, events, position, i, originalListener;

          checkListener(listener);

          events = this._events;
          if (events === undefined)
            return this;

          list = events[type];
          if (list === undefined)
            return this;

          if (list === listener || list.listener === listener) {
            if (--this._eventsCount === 0)
              this._events = Object.create(null);
            else {
              delete events[type];
              if (events.removeListener)
                this.emit('removeListener', type, list.listener || listener);
            }
          } else if (typeof list !== 'function') {
            position = -1;

            for (i = list.length - 1; i >= 0; i--) {
              if (list[i] === listener || list[i].listener === listener) {
                originalListener = list[i].listener;
                position = i;
                break;
              }
            }

            if (position < 0)
              return this;

            if (position === 0)
              list.shift();
            else {
              spliceOne(list, position);
            }

            if (list.length === 1)
              events[type] = list[0];

            if (events.removeListener !== undefined)
              this.emit('removeListener', type, originalListener || listener);
          }

          return this;
        };

    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

    EventEmitter.prototype.removeAllListeners =
        function removeAllListeners(type) {
          var listeners, events, i;

          events = this._events;
          if (events === undefined)
            return this;

          // not listening for removeListener, no need to emit
          if (events.removeListener === undefined) {
            if (arguments.length === 0) {
              this._events = Object.create(null);
              this._eventsCount = 0;
            } else if (events[type] !== undefined) {
              if (--this._eventsCount === 0)
                this._events = Object.create(null);
              else
                delete events[type];
            }
            return this;
          }

          // emit removeListener for all listeners on all events
          if (arguments.length === 0) {
            var keys = Object.keys(events);
            var key;
            for (i = 0; i < keys.length; ++i) {
              key = keys[i];
              if (key === 'removeListener') continue;
              this.removeAllListeners(key);
            }
            this.removeAllListeners('removeListener');
            this._events = Object.create(null);
            this._eventsCount = 0;
            return this;
          }

          listeners = events[type];

          if (typeof listeners === 'function') {
            this.removeListener(type, listeners);
          } else if (listeners !== undefined) {
            // LIFO order
            for (i = listeners.length - 1; i >= 0; i--) {
              this.removeListener(type, listeners[i]);
            }
          }

          return this;
        };

    function _listeners(target, type, unwrap) {
      var events = target._events;

      if (events === undefined)
        return [];

      var evlistener = events[type];
      if (evlistener === undefined)
        return [];

      if (typeof evlistener === 'function')
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];

      return unwrap ?
        unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }

    EventEmitter.prototype.listeners = function listeners(type) {
      return _listeners(this, type, true);
    };

    EventEmitter.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };

    EventEmitter.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === 'function') {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };

    EventEmitter.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events = this._events;

      if (events !== undefined) {
        var evlistener = events[type];

        if (typeof evlistener === 'function') {
          return 1;
        } else if (evlistener !== undefined) {
          return evlistener.length;
        }
      }

      return 0;
    }

    EventEmitter.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };

    function arrayClone(arr, n) {
      var copy = new Array(n);
      for (var i = 0; i < n; ++i)
        copy[i] = arr[i];
      return copy;
    }

    function spliceOne(list, index) {
      for (; index + 1 < list.length; index++)
        list[index] = list[index + 1];
      list.pop();
    }

    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }
      return ret;
    }

    function once(emitter, name) {
      return new Promise(function (resolve, reject) {
        function eventListener() {
          if (errorListener !== undefined) {
            emitter.removeListener('error', errorListener);
          }
          resolve([].slice.call(arguments));
        }    var errorListener;

        // Adding an error listener is not optional because
        // if an error is thrown on an event emitter we cannot
        // guarantee that the actual event we are waiting will
        // be fired. The result could be a silent way to create
        // memory or file descriptor leaks, which is something
        // we should avoid.
        if (name !== 'error') {
          errorListener = function errorListener(err) {
            emitter.removeListener(name, eventListener);
            reject(err);
          };

          emitter.once('error', errorListener);
        }

        emitter.once(name, eventListener);
      });
    }
    events.once = once_1;

    var MessagePortBase = /** @class */ (function () {
        function MessagePortBase() {
            this.emitter = new events.EventEmitter();
            this.started = false;
        }
        // MessagePort interface
        MessagePortBase.prototype.start = function () {
            this.started = true;
            this.receiveRemoteEvents();
        };
        MessagePortBase.prototype.close = function () {
            this.started = false;
        };
        Object.defineProperty(MessagePortBase.prototype, "onmessage", {
            set: function (listener) {
                this.addEventListener("message", listener);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MessagePortBase.prototype, "onmessageerror", {
            set: function (listener) {
                this.addEventListener("error", listener);
            },
            enumerable: false,
            configurable: true
        });
        MessagePortBase.prototype.addEventListener = function (type, listener) {
            this.emitter.addListener(type, listener);
            if (!this.started) {
                this.start();
            }
        };
        MessagePortBase.prototype.removeEventListener = function (type, listener) {
            this.emitter.removeListener(type, listener);
            if (this.emitter.listenerCount("message") === 0 || this.emitter.listenerCount("error") === 0) {
                this.close();
            }
        };
        MessagePortBase.prototype.dispatchEvent = function (event) {
            this.emitter.emit(event.type, event);
            return true;
        };
        MessagePortBase.prototype.receiveRemoteEvents = function () {
            var _this = this;
            if (!this.started) {
                return;
            }
            this.doReceiveRemoteEvents().then(function () {
                _this.receiveRemoteEvents();
            });
        };
        return MessagePortBase;
    }());

    /**
     * WebWorker side of Worker-like channel between browser context.
     *
     * Sends messages using [[self.postMessage]].
     */
    var WebWorkerMessagePort = /** @class */ (function (_super) {
        __extends(WebWorkerMessagePort, _super);
        function WebWorkerMessagePort() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * Receives `message` from `worker.postMessage` call.
             *
             * Pessage payload is in `message.data` field.
             */
            _this.onMessage = function (event) {
                _this.dispatchEvent(event);
            };
            return _this;
        }
        WebWorkerMessagePort.prototype.start = function () {
            self.addEventListener("message", this.onMessage);
        };
        WebWorkerMessagePort.prototype.close = function () {
            self.removeEventListener("message", this.onMessage);
        };
        WebWorkerMessagePort.prototype.postMessage = function (message) {
            self.postMessage(message);
        };
        WebWorkerMessagePort.prototype.doReceiveRemoteEvents = function () {
            throw new Error("Method not implemented.");
        };
        return WebWorkerMessagePort;
    }(MessagePortBase));

    function emitPageEvent(event) {
        if (!window.__pageEventQueue) {
            window.__pageEventQueue = [];
        }
        window.__pageEventQueue.push(event);
        if (window.__pageEventCallback) {
            window.__pageEventCallback();
            delete window.__pageEventCallback;
        }
    }
    function fetchPageCommand() {
        return new Promise(function (resolve) {
            function tryShiftCommand() {
                if (!window.__driverCommandQueue || window.__driverCommandQueue.length === 0) {
                    window.__driverCommandCallback = tryShiftCommand;
                    return;
                }
                var command = window.__driverCommandQueue.shift();
                resolve(JSON.parse(command));
            }
            tryShiftCommand();
        });
    }

    /**
     * Browser side of Worker-like channel between browser context.
     *
     * Sends messages serialized using [[createMochaStateSynchronizer]] using [[emitPageEvent]].
     */
    var BrowserMessagePort = /** @class */ (function (_super) {
        __extends(BrowserMessagePort, _super);
        function BrowserMessagePort() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        BrowserMessagePort.prototype.postMessage = function (message) {
            emitPageEvent({
                type: "message",
                data: message
            });
        };
        BrowserMessagePort.prototype.doReceiveRemoteEvents = function () {
            var _this = this;
            return fetchPageCommand().then(function (packet) {
                _this.dispatchEvent(packet);
            });
        };
        return BrowserMessagePort;
    }(MessagePortBase));

    function createCommonjsModule(fn, basedir, module) {
    	return module = {
    		path: basedir,
    		exports: {},
    		require: function (path, base) {
    			return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
    		}
    	}, fn(module, module.exports), module.exports;
    }

    function commonjsRequire () {
    	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
    }

    var treesync = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var SerializationContext = /** @class */ (function () {
        function SerializationContext() {
            this.objectsToState = new Map();
            this.idToState = new Map();
            this.customClassByConstructor = new Map();
            this.customClassByName = new Map();
            this.message = { root: null, objects: {} };
            this.nextId = 0;
            this.generation = 0;
        }
        SerializationContext.prototype.addClass = function (classDef) {
            this.customClassByConstructor.set(classDef.constructor, classDef);
            this.customClassByName.set(classDef.name, classDef);
        };
        return SerializationContext;
    }());
    exports.SerializationContext = SerializationContext;
    function isLeaf(object) {
        return (object === null ||
            typeof object === "string" ||
            typeof object === "boolean" ||
            typeof object === "undefined" ||
            typeof object === "number");
    }
    exports.isLeaf = isLeaf;
    function doSerializeLeaf(object) {
        if (object === null) {
            return null;
        }
        else if (typeof object === "string") {
            return object;
        }
        else if (typeof object === "boolean") {
            return object;
        }
        else if (typeof object === "undefined") {
            return { type: "undefined" };
        }
        else if (typeof object === "number") {
            if (object === Number.POSITIVE_INFINITY) {
                return { type: "infinity" };
            }
            else if (object === Number.NEGATIVE_INFINITY) {
                return { type: "-infinity" };
            }
            else if (isNaN(object)) {
                return { type: "nan" };
            }
            else {
                return object;
            }
        }
        else {
            throw new Error("doSerializeLeaf: unable to serialize '" + object + "' of type " + typeof object);
        }
    }
    function serializeProps(object, classDef, context) {
        var result = {};
        var propertyFilter = classDef && classDef.propertyFilter;
        var propertyMap = classDef && classDef.propertyMapSerialize;
        for (var prop in object) {
            if (object.hasOwnProperty(prop)) {
                if (propertyFilter && !propertyFilter(prop)) {
                    continue;
                }
                var value = object[prop];
                if (propertyMap) {
                    value = propertyMap(prop, value);
                }
                result[prop] = serializeValue(value, context);
            }
        }
        return result;
    }
    function doSerializeObject(object, context) {
        if (Array.isArray(object)) {
            return {
                type: "array",
                value: object.map(function (item) { return serializeValue(item, context); })
            };
        }
        else if (object instanceof Error) {
            // ensure that both stack and message are captured from Errors
            var value = serializeProps(object, undefined, context);
            value.message = object.message || object.toString();
            value.stack = object.stack || "";
            return { type: "error", value: value };
        }
        else {
            var constructor = object.constructor;
            var classDef = context.customClassByConstructor && context.customClassByConstructor.get(constructor);
            if (classDef) {
                return { type: classDef.name, value: serializeProps(object, classDef, context) };
            }
            else if (constructor === Date) {
                return { type: "date", value: object.getTime() };
            }
            else if (constructor === RegExp) {
                var regexp = object;
                return {
                    type: "regexp",
                    value: {
                        source: regexp.source,
                        flags: regexp.flags
                    }
                };
            }
            else if (object instanceof ArrayBuffer) {
                var b = new Blob([object]);
                throw new Error("doSerializeObject: ArrayBuffer not yet supported");
                // return {
                //     type: "arraybuffer",
                //     value: "TBD"
                // }
            }
            else {
                return { type: "object", value: serializeProps(object, classDef, context) };
            }
        }
    }
    function doCreateInstance(object, context) {
        if (object.type === "array") {
            return [];
        }
        else if (object.type === "error") {
            return new Error("dummy-message");
        }
        else if (object.type === "date") {
            if (typeof object.value !== "number") {
                throw new Error("doDeserializeObject: invalid value for date: '" + object.value + "'");
            }
            return new Date(object.value);
        }
        else if (object.type === "regexp") {
            if (typeof object.value !== "object") {
                throw new Error("doDeserializeObject: invalid value for regexp: '" + object.value + "'");
            }
            var regexpValue = object.value;
            return new RegExp(regexpValue.source, regexpValue.flags);
        }
        else if (object.type === "arraybuffer") {
            throw new Error("doCreateInstance: ArrayBuffer not yet supported");
        }
        else {
            if (object.type === "object") {
                return {};
            }
            else {
                var classDef = context && context.customClassByName.get(object.type);
                if (!classDef) {
                    throw new Error("doDeserializeObject: invalid type '" + object.type + "'");
                }
                if (classDef.factory) {
                    var factory = classDef.factory;
                    return factory();
                }
                else if (classDef.constructor) {
                    var constructor = classDef.constructor;
                    return new constructor();
                }
                else {
                    throw new Error("doDeserializeObject: class '" + object.type + "' has neither factory or constructor defined");
                }
            }
        }
    }
    function doFillInstanceChildren(instance, object, context) {
        if (object.type === "date" || object.type === "regexp") {
            return;
        }
        if (object.type === "array") {
            if (!Array.isArray(object.value)) {
                throw new Error("doFillInstanceChildren: expected array as value for type 'array'");
            }
            var srcArray = object.value;
            instance.length = srcArray.length;
            srcArray.forEach(function (item, i) {
                instance[i] = deserializeValue(item, context);
            });
        }
        else {
            if (object.value) {
                var classDef = context.customClassByConstructor && context.customClassByConstructor.get(instance.constructor);
                var propertyMap = classDef && classDef.propertyMapDeserialize;
                for (var prop in object.value) {
                    var propValue = object.value[prop];
                    if (propValue !== null && propValue !== undefined && propValue.type === "delete-prop") {
                        delete instance[prop];
                    }
                    else {
                        var value = deserializeValue(propValue, context);
                        if (propertyMap) {
                            value = propertyMap(prop, value);
                        }
                        instance[prop] = value;
                    }
                }
            }
        }
    }
    function shalowEquals(a, b) {
        if (typeof a !== typeof b) {
            return false;
        }
        else if (typeof a === "number" && isNaN(a) && isNaN(b)) {
            return true;
        }
        else if (Array.isArray(a)) {
            var length_1 = a.length;
            if (length_1 !== b.length) {
                return false;
            }
            for (var i = 0; i < length_1; i++) {
                if (a[i] !== b[i]) {
                    return false;
                }
            }
            return true;
        }
        else if (typeof a === "object") {
            for (var keyA in a) {
                if (!(keyA in b)) {
                    return false;
                }
            }
            for (var keyB in b) {
                if (a[keyB] !== b[keyB]) {
                    return false;
                }
            }
            return true;
        }
        else {
            return a === b;
        }
    }
    function shallowClone(object) {
        if (Array.isArray(object)) {
            return object.slice();
        }
        if (typeof object === "object") {
            return Object.assign({}, object);
        }
        if (object instanceof Date) {
            return new Date(object.getTime());
        }
        if (object instanceof RegExp) {
            return new RegExp(object.source, object.flags);
        }
        return object;
    }
    function serializeShareableObject(object, context) {
        var state = context.objectsToState.get(object);
        if (state === undefined) {
            var id = (context.nextId++).toString();
            state = { id: id };
            context.objectsToState.set(object, state);
        }
        if (state.generation === undefined || state.generation < context.generation) {
            state.generation = context.generation;
            if (state.previousValue === undefined || shalowEquals(state.previousValue, object) === false) {
                state.previousValue = shallowClone(object);
                var value = doSerializeObject(object, context);
                value.id = state.id;
                context.message.objects[value.id] = value;
            }
        }
        return { type: "ref", value: state.id };
    }
    function deserializeShareableObject(object, context) {
        var id = object.id;
        var state = context.idToState.get(id);
        if (state === undefined) {
            state = { id: id };
            context.idToState.set(id, state);
            var value = doCreateInstance(object, context);
            state.instance = value;
        }
        if (state.generation === undefined || state.generation < context.generation) {
            state.generation = context.generation;
            doFillInstanceChildren(state.instance, object, context);
        }
        return state.instance;
    }
    function serializeValue(object, context) {
        return isLeaf(object) ? doSerializeLeaf(object) : serializeShareableObject(object, context);
    }
    exports.serializeValue = serializeValue;
    function buildMessage(object, context) {
        if (context === undefined) {
            context = new SerializationContext();
        }
        context.message = { root: null, objects: {} };
        context.message.root = serializeValue(object, context);
        context.generation++;
        return context.message;
    }
    exports.buildMessage = buildMessage;
    function serialize(object, context) {
        return JSON.stringify(buildMessage(object, context));
    }
    exports.serialize = serialize;
    function deserializeRef(object, context) {
        var id = object.value;
        if (typeof id !== "string") {
            throw new Error("deserialize: invalid ref: " + id);
        }
        var state = context.idToState.get(id);
        var serializedObject = context.message.objects[id];
        if (state !== undefined) {
            if (!serializedObject) {
                // no update, just return old instance
                return state.instance;
            }
            else {
                // update
                if (state.generation === undefined || state.generation < context.generation) {
                    state.generation = context.generation;
                    doFillInstanceChildren(state.instance, serializedObject, context);
                }
                return state.instance;
            }
        }
        else if (serializedObject) {
            return deserializeShareableObject(serializedObject, context);
        }
        throw new Error("deserialize: unknown ref: " + object.value);
    }
    exports.deserializeRef = deserializeRef;
    function deserializeValue(object, context) {
        if (object === null) {
            return null;
        }
        else if (typeof object === "string") {
            return object;
        }
        else if (typeof object === "boolean") {
            return object;
        }
        else if (typeof object === "number") {
            return object;
        }
        else if (typeof object === "object") {
            if (object.type === "infinity") {
                return Number.POSITIVE_INFINITY;
            }
            else if (object.type === "-infinity") {
                return Number.NEGATIVE_INFINITY;
            }
            else if (object.type === "nan") {
                return Number.NaN;
            }
            else if (object.type === "undefined") {
                return undefined;
            }
            else if (object.type === "ref") {
                return deserializeRef(object, context);
            }
            else {
                return deserializeShareableObject(object, context);
            }
        }
        else {
            throw new Error("deserialize: invalid transport value: " + object);
        }
    }
    exports.deserializeValue = deserializeValue;
    function decodeMessage(message, context) {
        if (context === undefined) {
            context = new SerializationContext();
        }
        context.message = message;
        var root = deserializeValue(message.root, context);
        context.generation++;
        return root;
    }
    exports.decodeMessage = decodeMessage;
    function deserialize(payload, context) {
        return decodeMessage(JSON.parse(payload), context);
    }
    exports.deserialize = deserialize;
    var Synchronizer = /** @class */ (function () {
        function Synchronizer() {
            this.serializationContext = new SerializationContext();
        }
        Synchronizer.prototype.buildPacket = function (object) {
            return serialize(object, this.serializationContext);
        };
        Synchronizer.prototype.decodePacket = function (payload) {
            return deserialize(payload, this.serializationContext);
        };
        return Synchronizer;
    }());
    exports.Synchronizer = Synchronizer;
    });

    exports.currentOptions = {};
    var MAGIC_TIMEOUT = 312345678;
    function inWebWorkerContext() {
        return typeof self !== "undefined" && typeof self.importScripts !== "undefined";
    }
    var runnerBackChannel = inWebWorkerContext()
        ? new WebWorkerMessagePort()
        : new BrowserMessagePort();
    function applyMochaOptions(mocha, options) {
        exports.currentOptions = __assign(__assign({}, exports.currentOptions), options);
        if (options.captureConsoleLog) {
            installConsoleLogForwarder();
        }
        if (options.checkLeaks !== undefined) {
            // TODO: mocha typings lack 'boolean' arg for checkLeaks
            mocha.checkLeaks(options.checkLeaks);
        }
        if (options.globals !== undefined) {
            mocha.globals(options.globals);
        }
        if (options.grep) {
            mocha.grep(options.grep);
        }
        {
            var timeout = options.timeout !== undefined ? options.timeout : 2000;
            overrideDefaultMagicTimeout(mocha.suite, timeout);
            mocha.timeout(timeout);
        }
    }
    function overrideDefaultMagicTimeout(suite, timeout) {
        var overrideMagicTimeout = function (obj) {
            if (obj.timeout() === MAGIC_TIMEOUT) {
                obj.timeout(timeout);
            }
        };
        overrideMagicTimeout(suite);
        suite.tests.forEach(overrideMagicTimeout);
        suite._beforeEach.forEach(overrideMagicTimeout);
        suite._beforeAll.forEach(overrideMagicTimeout);
        suite._afterEach.forEach(overrideMagicTimeout);
        suite._afterAll.forEach(overrideMagicTimeout);
        suite.suites.forEach(function (subSuite) {
            overrideDefaultMagicTimeout(subSuite, timeout);
        });
    }
    var consoleLogSenderInstalled = false;
    /**
     * Hijack `console.*` to send all logs to parent through `runnerBackChannel`.
     */
    function installConsoleLogForwarder() {
        if (consoleLogSenderInstalled) {
            return;
        }
        consoleLogSenderInstalled = true;
        var originalConsole = {
            log: console.log,
            info: console.info,
            warn: console.warn,
            error: console.error
        };
        function runnerLogForwarder(level) {
            return function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                originalConsole[level].apply(console, args);
                runnerBackChannel.postMessage({
                    type: "log",
                    level: level,
                    args: treesync.buildMessage(args)
                });
            };
        }
        console.log = runnerLogForwarder("log");
        console.info = runnerLogForwarder("info");
        console.warn = runnerLogForwarder("warn");
        console.error = runnerLogForwarder("error");
    }
    var globalErrorHandlersInstalled = false;
    function installGlobalErrorHandlers() {
        if (globalErrorHandlersInstalled) {
            return;
        }
        globalErrorHandlersInstalled = true;
        self.addEventListener("unhandledrejection", function (event) {
            runnerBackChannel.postMessage({
                type: "err-unhandled-exception",
                message: "Unhandled rejection in Browser context.",
                error: treesync.buildMessage(event.reason)
            });
        });
        self.addEventListener("error", function (event) {
            runnerBackChannel.postMessage({
                type: "err-unhandled-exception",
                message: "Unhandled error in Browser context.",
                error: treesync.buildMessage(event.error || event.message)
            });
        });
    }

    var MOCHA_SUITE_SYNCHRONIZED_PROPERTIES = [
        "title",
        "tests",
        "_beforeAll",
        "_afterAll",
        "_beforeEach",
        "_afterEach",
        "suites",
        "pending",
        "passes",
        "failures",
        "file",
        "delayed",
        "parent",
        "root",
        "rootEmpty",
        "duration",
        "title"
    ];
    var MOCHA_TEST_SYNCHRONIZED_PROPERTIES = [
        "title",
        "speed",
        "body",
        "fn",
        "type",
        "err",
        "parent",
        "title",
        "state",
        "pending",
        "skipped",
        "duration",
        "currentRetry",
        "context",
        "ctx"
    ];
    var MOCHA_HOOK_SYNCHRONIZED_PROPERTIES = ["title", "type", "state", "duration", "parent", "fn", "ctx", "file"];
    function createMochaStateSynchronizer() {
        var synchronizer = new treesync.Synchronizer();
        if (typeof mocha__namespace === "undefined") {
            throw new Error("mocha not loaded, cannot create Mocha Suite/Test synchronizer");
        }
        synchronizer.serializationContext.addClass({
            name: "Mocha.Suite",
            constructor: mocha$1.Suite,
            factory: function () {
                return new mocha$1.Suite("dummy-test");
            },
            propertyFilter: function (name) {
                return MOCHA_SUITE_SYNCHRONIZED_PROPERTIES.includes(name);
            }
        });
        synchronizer.serializationContext.addClass({
            name: "Mocha.Test",
            constructor: mocha$1.Test,
            factory: function () {
                return new mocha$1.Test("dummy-test", function () { });
            },
            propertyFilter: function (name) {
                return MOCHA_TEST_SYNCHRONIZED_PROPERTIES.includes(name);
            },
            propertyMapSerialize: function (name, value) {
                if (name === "fn" && typeof value === "function") {
                    return value.toString();
                }
                return value;
            }
        });
        synchronizer.serializationContext.addClass({
            name: "Mocha.Hook",
            constructor: mocha$1.Hook,
            factory: function () {
                return new mocha$1.Hook("dummy-hook");
            },
            propertyFilter: function (name) {
                return MOCHA_HOOK_SYNCHRONIZED_PROPERTIES.includes(name);
            },
            propertyMapSerialize: function (name, value) {
                if (name === "fn" && typeof value === "function") {
                    return value.toString();
                }
                return value;
            }
        });
        return synchronizer;
    }

    var myGlobalThis = typeof globalThis !== "undefined" ? globalThis : (new Function("return this"))();
    /**
     * This reporter sends all events received from `Mocha.Runner` to
     * [[runRemoteMochaTest]] through [[runnerBackChannel]].
     *
     * It sends messages of type `mocha-runner-event`, with event contens serialized using
     * `suite-synchronizer`.
     */
    var MochaRemoteReporter = /** @class */ (function () {
        function MochaRemoteReporter(runner) {
            var passes = 0;
            var failures = 0;
            var synchronizer = createMochaStateSynchronizer();
            function forwardRunnerEvent(event) {
                runnerBackChannel.postMessage({
                    type: "mocha-runner-event",
                    event: synchronizer.buildPacket(event)
                });
            }
            // TODO: hook events
            runner.on("start", function () {
                forwardRunnerEvent({
                    type: "start",
                    suite: runner.suite
                });
            });
            runner.on("suite", function (suite) {
                forwardRunnerEvent({
                    type: "suite",
                    suite: suite
                });
            });
            runner.on("suite end", function (suite) {
                forwardRunnerEvent({
                    type: "suite end",
                    suite: suite
                });
            });
            runner.on("test", function (test) {
                forwardRunnerEvent({
                    type: "test",
                    test: test
                });
            });
            runner.on("test end", function (test) {
                forwardRunnerEvent({
                    type: "test end",
                    test: test
                });
            });
            runner.on("pending", function (test) {
                forwardRunnerEvent({
                    type: "pending",
                    test: test
                });
            });
            runner.on("pass", function (test) {
                passes++;
                forwardRunnerEvent({
                    type: "pass",
                    test: test
                });
            });
            runner.on("fail", function (test, err) {
                failures++;
                forwardRunnerEvent({
                    type: "fail",
                    test: test,
                    err: err
                });
            });
            runner.on("end", function () {
                var e_1, _a;
                if (exports.currentOptions.globalsToSave !== undefined) {
                    try {
                        for (var _b = __values(exports.currentOptions.globalsToSave), _c = _b.next(); !_c.done; _c = _b.next()) {
                            var globalName = _c.value;
                            var value = myGlobalThis[globalName];
                            runnerBackChannel.postMessage({
                                type: "var-dump",
                                name: globalName,
                                value: treesync.buildMessage(value)
                            });
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                }
                forwardRunnerEvent({
                    type: "end",
                    passes: passes,
                    failures: failures,
                    stats: runner.stats
                });
            });
        }
        return MochaRemoteReporter;
    }());

    var has = Object.prototype.hasOwnProperty;
    var isArray = Array.isArray;

    var hexTable = (function () {
        var array = [];
        for (var i = 0; i < 256; ++i) {
            array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
        }

        return array;
    }());

    var compactQueue = function compactQueue(queue) {
        while (queue.length > 1) {
            var item = queue.pop();
            var obj = item.obj[item.prop];

            if (isArray(obj)) {
                var compacted = [];

                for (var j = 0; j < obj.length; ++j) {
                    if (typeof obj[j] !== 'undefined') {
                        compacted.push(obj[j]);
                    }
                }

                item.obj[item.prop] = compacted;
            }
        }
    };

    var arrayToObject = function arrayToObject(source, options) {
        var obj = options && options.plainObjects ? Object.create(null) : {};
        for (var i = 0; i < source.length; ++i) {
            if (typeof source[i] !== 'undefined') {
                obj[i] = source[i];
            }
        }

        return obj;
    };

    var merge = function merge(target, source, options) {
        /* eslint no-param-reassign: 0 */
        if (!source) {
            return target;
        }

        if (typeof source !== 'object') {
            if (isArray(target)) {
                target.push(source);
            } else if (target && typeof target === 'object') {
                if ((options && (options.plainObjects || options.allowPrototypes)) || !has.call(Object.prototype, source)) {
                    target[source] = true;
                }
            } else {
                return [target, source];
            }

            return target;
        }

        if (!target || typeof target !== 'object') {
            return [target].concat(source);
        }

        var mergeTarget = target;
        if (isArray(target) && !isArray(source)) {
            mergeTarget = arrayToObject(target, options);
        }

        if (isArray(target) && isArray(source)) {
            source.forEach(function (item, i) {
                if (has.call(target, i)) {
                    var targetItem = target[i];
                    if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {
                        target[i] = merge(targetItem, item, options);
                    } else {
                        target.push(item);
                    }
                } else {
                    target[i] = item;
                }
            });
            return target;
        }

        return Object.keys(source).reduce(function (acc, key) {
            var value = source[key];

            if (has.call(acc, key)) {
                acc[key] = merge(acc[key], value, options);
            } else {
                acc[key] = value;
            }
            return acc;
        }, mergeTarget);
    };

    var assign = function assignSingleSource(target, source) {
        return Object.keys(source).reduce(function (acc, key) {
            acc[key] = source[key];
            return acc;
        }, target);
    };

    var decode = function (str, decoder, charset) {
        var strWithoutPlus = str.replace(/\+/g, ' ');
        if (charset === 'iso-8859-1') {
            // unescape never throws, no try...catch needed:
            return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
        }
        // utf-8
        try {
            return decodeURIComponent(strWithoutPlus);
        } catch (e) {
            return strWithoutPlus;
        }
    };

    var encode = function encode(str, defaultEncoder, charset) {
        // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
        // It has been adapted here for stricter adherence to RFC 3986
        if (str.length === 0) {
            return str;
        }

        var string = str;
        if (typeof str === 'symbol') {
            string = Symbol.prototype.toString.call(str);
        } else if (typeof str !== 'string') {
            string = String(str);
        }

        if (charset === 'iso-8859-1') {
            return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {
                return '%26%23' + parseInt($0.slice(2), 16) + '%3B';
            });
        }

        var out = '';
        for (var i = 0; i < string.length; ++i) {
            var c = string.charCodeAt(i);

            if (
                c === 0x2D // -
                || c === 0x2E // .
                || c === 0x5F // _
                || c === 0x7E // ~
                || (c >= 0x30 && c <= 0x39) // 0-9
                || (c >= 0x41 && c <= 0x5A) // a-z
                || (c >= 0x61 && c <= 0x7A) // A-Z
            ) {
                out += string.charAt(i);
                continue;
            }

            if (c < 0x80) {
                out = out + hexTable[c];
                continue;
            }

            if (c < 0x800) {
                out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);
                continue;
            }

            if (c < 0xD800 || c >= 0xE000) {
                out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);
                continue;
            }

            i += 1;
            c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));
            out += hexTable[0xF0 | (c >> 18)]
                + hexTable[0x80 | ((c >> 12) & 0x3F)]
                + hexTable[0x80 | ((c >> 6) & 0x3F)]
                + hexTable[0x80 | (c & 0x3F)];
        }

        return out;
    };

    var compact = function compact(value) {
        var queue = [{ obj: { o: value }, prop: 'o' }];
        var refs = [];

        for (var i = 0; i < queue.length; ++i) {
            var item = queue[i];
            var obj = item.obj[item.prop];

            var keys = Object.keys(obj);
            for (var j = 0; j < keys.length; ++j) {
                var key = keys[j];
                var val = obj[key];
                if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
                    queue.push({ obj: obj, prop: key });
                    refs.push(val);
                }
            }
        }

        compactQueue(queue);

        return value;
    };

    var isRegExp = function isRegExp(obj) {
        return Object.prototype.toString.call(obj) === '[object RegExp]';
    };

    var isBuffer = function isBuffer(obj) {
        if (!obj || typeof obj !== 'object') {
            return false;
        }

        return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
    };

    var combine = function combine(a, b) {
        return [].concat(a, b);
    };

    var maybeMap = function maybeMap(val, fn) {
        if (isArray(val)) {
            var mapped = [];
            for (var i = 0; i < val.length; i += 1) {
                mapped.push(fn(val[i]));
            }
            return mapped;
        }
        return fn(val);
    };

    var utils = {
        arrayToObject: arrayToObject,
        assign: assign,
        combine: combine,
        compact: compact,
        decode: decode,
        encode: encode,
        isBuffer: isBuffer,
        isRegExp: isRegExp,
        maybeMap: maybeMap,
        merge: merge
    };

    var replace = String.prototype.replace;
    var percentTwenties = /%20/g;



    var Format = {
        RFC1738: 'RFC1738',
        RFC3986: 'RFC3986'
    };

    var formats = utils.assign(
        {
            'default': Format.RFC3986,
            formatters: {
                RFC1738: function (value) {
                    return replace.call(value, percentTwenties, '+');
                },
                RFC3986: function (value) {
                    return String(value);
                }
            }
        },
        Format
    );

    var has$1 = Object.prototype.hasOwnProperty;

    var arrayPrefixGenerators = {
        brackets: function brackets(prefix) {
            return prefix + '[]';
        },
        comma: 'comma',
        indices: function indices(prefix, key) {
            return prefix + '[' + key + ']';
        },
        repeat: function repeat(prefix) {
            return prefix;
        }
    };

    var isArray$1 = Array.isArray;
    var push = Array.prototype.push;
    var pushToArray = function (arr, valueOrArray) {
        push.apply(arr, isArray$1(valueOrArray) ? valueOrArray : [valueOrArray]);
    };

    var toISO = Date.prototype.toISOString;

    var defaultFormat = formats['default'];
    var defaults = {
        addQueryPrefix: false,
        allowDots: false,
        charset: 'utf-8',
        charsetSentinel: false,
        delimiter: '&',
        encode: true,
        encoder: utils.encode,
        encodeValuesOnly: false,
        format: defaultFormat,
        formatter: formats.formatters[defaultFormat],
        // deprecated
        indices: false,
        serializeDate: function serializeDate(date) {
            return toISO.call(date);
        },
        skipNulls: false,
        strictNullHandling: false
    };

    var isNonNullishPrimitive = function isNonNullishPrimitive(v) {
        return typeof v === 'string'
            || typeof v === 'number'
            || typeof v === 'boolean'
            || typeof v === 'symbol'
            || typeof v === 'bigint';
    };

    var stringify = function stringify(
        object,
        prefix,
        generateArrayPrefix,
        strictNullHandling,
        skipNulls,
        encoder,
        filter,
        sort,
        allowDots,
        serializeDate,
        formatter,
        encodeValuesOnly,
        charset
    ) {
        var obj = object;
        if (typeof filter === 'function') {
            obj = filter(prefix, obj);
        } else if (obj instanceof Date) {
            obj = serializeDate(obj);
        } else if (generateArrayPrefix === 'comma' && isArray$1(obj)) {
            obj = utils.maybeMap(obj, function (value) {
                if (value instanceof Date) {
                    return serializeDate(value);
                }
                return value;
            }).join(',');
        }

        if (obj === null) {
            if (strictNullHandling) {
                return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, 'key') : prefix;
            }

            obj = '';
        }

        if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
            if (encoder) {
                var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, 'key');
                return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset, 'value'))];
            }
            return [formatter(prefix) + '=' + formatter(String(obj))];
        }

        var values = [];

        if (typeof obj === 'undefined') {
            return values;
        }

        var objKeys;
        if (isArray$1(filter)) {
            objKeys = filter;
        } else {
            var keys = Object.keys(obj);
            objKeys = sort ? keys.sort(sort) : keys;
        }

        for (var i = 0; i < objKeys.length; ++i) {
            var key = objKeys[i];
            var value = obj[key];

            if (skipNulls && value === null) {
                continue;
            }

            var keyPrefix = isArray$1(obj)
                ? typeof generateArrayPrefix === 'function' ? generateArrayPrefix(prefix, key) : prefix
                : prefix + (allowDots ? '.' + key : '[' + key + ']');

            pushToArray(values, stringify(
                value,
                keyPrefix,
                generateArrayPrefix,
                strictNullHandling,
                skipNulls,
                encoder,
                filter,
                sort,
                allowDots,
                serializeDate,
                formatter,
                encodeValuesOnly,
                charset
            ));
        }

        return values;
    };

    var normalizeStringifyOptions = function normalizeStringifyOptions(opts) {
        if (!opts) {
            return defaults;
        }

        if (opts.encoder !== null && opts.encoder !== undefined && typeof opts.encoder !== 'function') {
            throw new TypeError('Encoder has to be a function.');
        }

        var charset = opts.charset || defaults.charset;
        if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
            throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
        }

        var format = formats['default'];
        if (typeof opts.format !== 'undefined') {
            if (!has$1.call(formats.formatters, opts.format)) {
                throw new TypeError('Unknown format option provided.');
            }
            format = opts.format;
        }
        var formatter = formats.formatters[format];

        var filter = defaults.filter;
        if (typeof opts.filter === 'function' || isArray$1(opts.filter)) {
            filter = opts.filter;
        }

        return {
            addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,
            allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,
            charset: charset,
            charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
            delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,
            encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,
            encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,
            encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
            filter: filter,
            formatter: formatter,
            serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,
            skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,
            sort: typeof opts.sort === 'function' ? opts.sort : null,
            strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
        };
    };

    var stringify_1 = function (object, opts) {
        var obj = object;
        var options = normalizeStringifyOptions(opts);

        var objKeys;
        var filter;

        if (typeof options.filter === 'function') {
            filter = options.filter;
            obj = filter('', obj);
        } else if (isArray$1(options.filter)) {
            filter = options.filter;
            objKeys = filter;
        }

        var keys = [];

        if (typeof obj !== 'object' || obj === null) {
            return '';
        }

        var arrayFormat;
        if (opts && opts.arrayFormat in arrayPrefixGenerators) {
            arrayFormat = opts.arrayFormat;
        } else if (opts && 'indices' in opts) {
            arrayFormat = opts.indices ? 'indices' : 'repeat';
        } else {
            arrayFormat = 'indices';
        }

        var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];

        if (!objKeys) {
            objKeys = Object.keys(obj);
        }

        if (options.sort) {
            objKeys.sort(options.sort);
        }

        for (var i = 0; i < objKeys.length; ++i) {
            var key = objKeys[i];

            if (options.skipNulls && obj[key] === null) {
                continue;
            }
            pushToArray(keys, stringify(
                obj[key],
                key,
                generateArrayPrefix,
                options.strictNullHandling,
                options.skipNulls,
                options.encode ? options.encoder : null,
                options.filter,
                options.sort,
                options.allowDots,
                options.serializeDate,
                options.formatter,
                options.encodeValuesOnly,
                options.charset
            ));
        }

        var joined = keys.join(options.delimiter);
        var prefix = options.addQueryPrefix === true ? '?' : '';

        if (options.charsetSentinel) {
            if (options.charset === 'iso-8859-1') {
                // encodeURIComponent('&#10003;'), the "numeric entity" representation of a checkmark
                prefix += 'utf8=%26%2310003%3B&';
            } else {
                // encodeURIComponent('✓')
                prefix += 'utf8=%E2%9C%93&';
            }
        }

        return joined.length > 0 ? prefix + joined : '';
    };

    var has$2 = Object.prototype.hasOwnProperty;
    var isArray$2 = Array.isArray;

    var defaults$1 = {
        allowDots: false,
        allowPrototypes: false,
        arrayLimit: 20,
        charset: 'utf-8',
        charsetSentinel: false,
        comma: false,
        decoder: utils.decode,
        delimiter: '&',
        depth: 5,
        ignoreQueryPrefix: false,
        interpretNumericEntities: false,
        parameterLimit: 1000,
        parseArrays: true,
        plainObjects: false,
        strictNullHandling: false
    };

    var interpretNumericEntities = function (str) {
        return str.replace(/&#(\d+);/g, function ($0, numberStr) {
            return String.fromCharCode(parseInt(numberStr, 10));
        });
    };

    var parseArrayValue = function (val, options) {
        if (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {
            return val.split(',');
        }

        return val;
    };

    // This is what browsers will submit when the ✓ character occurs in an
    // application/x-www-form-urlencoded body and the encoding of the page containing
    // the form is iso-8859-1, or when the submitted form has an accept-charset
    // attribute of iso-8859-1. Presumably also with other charsets that do not contain
    // the ✓ character, such as us-ascii.
    var isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')

    // These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.
    var charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('✓')

    var parseValues = function parseQueryStringValues(str, options) {
        var obj = {};
        var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
        var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
        var parts = cleanStr.split(options.delimiter, limit);
        var skipIndex = -1; // Keep track of where the utf8 sentinel was found
        var i;

        var charset = options.charset;
        if (options.charsetSentinel) {
            for (i = 0; i < parts.length; ++i) {
                if (parts[i].indexOf('utf8=') === 0) {
                    if (parts[i] === charsetSentinel) {
                        charset = 'utf-8';
                    } else if (parts[i] === isoSentinel) {
                        charset = 'iso-8859-1';
                    }
                    skipIndex = i;
                    i = parts.length; // The eslint settings do not allow break;
                }
            }
        }

        for (i = 0; i < parts.length; ++i) {
            if (i === skipIndex) {
                continue;
            }
            var part = parts[i];

            var bracketEqualsPos = part.indexOf(']=');
            var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;

            var key, val;
            if (pos === -1) {
                key = options.decoder(part, defaults$1.decoder, charset, 'key');
                val = options.strictNullHandling ? null : '';
            } else {
                key = options.decoder(part.slice(0, pos), defaults$1.decoder, charset, 'key');
                val = utils.maybeMap(
                    parseArrayValue(part.slice(pos + 1), options),
                    function (encodedVal) {
                        return options.decoder(encodedVal, defaults$1.decoder, charset, 'value');
                    }
                );
            }

            if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {
                val = interpretNumericEntities(val);
            }

            if (part.indexOf('[]=') > -1) {
                val = isArray$2(val) ? [val] : val;
            }

            if (has$2.call(obj, key)) {
                obj[key] = utils.combine(obj[key], val);
            } else {
                obj[key] = val;
            }
        }

        return obj;
    };

    var parseObject = function (chain, val, options, valuesParsed) {
        var leaf = valuesParsed ? val : parseArrayValue(val, options);

        for (var i = chain.length - 1; i >= 0; --i) {
            var obj;
            var root = chain[i];

            if (root === '[]' && options.parseArrays) {
                obj = [].concat(leaf);
            } else {
                obj = options.plainObjects ? Object.create(null) : {};
                var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
                var index = parseInt(cleanRoot, 10);
                if (!options.parseArrays && cleanRoot === '') {
                    obj = { 0: leaf };
                } else if (
                    !isNaN(index)
                    && root !== cleanRoot
                    && String(index) === cleanRoot
                    && index >= 0
                    && (options.parseArrays && index <= options.arrayLimit)
                ) {
                    obj = [];
                    obj[index] = leaf;
                } else {
                    obj[cleanRoot] = leaf;
                }
            }

            leaf = obj; // eslint-disable-line no-param-reassign
        }

        return leaf;
    };

    var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
        if (!givenKey) {
            return;
        }

        // Transform dot notation to bracket notation
        var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;

        // The regex chunks

        var brackets = /(\[[^[\]]*])/;
        var child = /(\[[^[\]]*])/g;

        // Get the parent

        var segment = options.depth > 0 && brackets.exec(key);
        var parent = segment ? key.slice(0, segment.index) : key;

        // Stash the parent if it exists

        var keys = [];
        if (parent) {
            // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties
            if (!options.plainObjects && has$2.call(Object.prototype, parent)) {
                if (!options.allowPrototypes) {
                    return;
                }
            }

            keys.push(parent);
        }

        // Loop through children appending to the array until we hit depth

        var i = 0;
        while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
            i += 1;
            if (!options.plainObjects && has$2.call(Object.prototype, segment[1].slice(1, -1))) {
                if (!options.allowPrototypes) {
                    return;
                }
            }
            keys.push(segment[1]);
        }

        // If there's a remainder, just add whatever is left

        if (segment) {
            keys.push('[' + key.slice(segment.index) + ']');
        }

        return parseObject(keys, val, options, valuesParsed);
    };

    var normalizeParseOptions = function normalizeParseOptions(opts) {
        if (!opts) {
            return defaults$1;
        }

        if (opts.decoder !== null && opts.decoder !== undefined && typeof opts.decoder !== 'function') {
            throw new TypeError('Decoder has to be a function.');
        }

        if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
            throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
        }
        var charset = typeof opts.charset === 'undefined' ? defaults$1.charset : opts.charset;

        return {
            allowDots: typeof opts.allowDots === 'undefined' ? defaults$1.allowDots : !!opts.allowDots,
            allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults$1.allowPrototypes,
            arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults$1.arrayLimit,
            charset: charset,
            charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults$1.charsetSentinel,
            comma: typeof opts.comma === 'boolean' ? opts.comma : defaults$1.comma,
            decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults$1.decoder,
            delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults$1.delimiter,
            // eslint-disable-next-line no-implicit-coercion, no-extra-parens
            depth: (typeof opts.depth === 'number' || opts.depth === false) ? +opts.depth : defaults$1.depth,
            ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
            interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults$1.interpretNumericEntities,
            parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults$1.parameterLimit,
            parseArrays: opts.parseArrays !== false,
            plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults$1.plainObjects,
            strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults$1.strictNullHandling
        };
    };

    var parse = function (str, opts) {
        var options = normalizeParseOptions(opts);

        if (str === '' || str === null || typeof str === 'undefined') {
            return options.plainObjects ? Object.create(null) : {};
        }

        var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
        var obj = options.plainObjects ? Object.create(null) : {};

        // Iterate over the keys and setup the new object

        var keys = Object.keys(tempObj);
        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            var newObj = parseKeys(key, tempObj[key], options, typeof str === 'string');
            obj = utils.merge(obj, newObj, options);
        }

        return utils.compact(obj);
    };

    var lib = {
        formats: formats,
        parse: parse,
        stringify: stringify_1
    };

    /**
     * Adds mocha instance which will send test events, when ran.
     *  - use [[MochaWebdriverReporter]] to gather events
     *  - sends events to [[runRemoteMochaTest]]
     *
     * Note, default `Mocha` instance i.e `(global|window|self).mocha` is added by default, so
     * there is no reason to use this funciton manually, see [[initializeMochaWebDriverClient]].
     *
     * May be used both in "main" thread or in web worker thread. When executed in worker, it's
     * expected that worker instance in main thread is also registered for forwarding using
     * [[addWorkerSource]].
     */
    function addMochaSource(mocha) {
        installGlobalErrorHandlers();
        mocha.reporter(MochaRemoteReporter);
        mocha.globals(["__pageEventQueue", "__pageEventCallback", "__driverCommandCallback", "__driverCommandQueue"]);
        if (exports.queryStringRunnerOptions !== undefined) {
            applyMochaOptions(mocha, exports.queryStringRunnerOptions);
        }
        else {
            delayMochaRun(mocha);
        }
    }
    function delayMochaRun(mocha) {
        //
        // HACK NOTE:
        //
        // Initialize mocha timeout with rubbish, so we can detect not-customized timeouts later.
        // All tests, hook & suites with timeout() == MAGIC_TIMEOUT have it overriden later in
        // `applyMochaOptions` when actual timeout value is received from driver.
        //
        mocha.timeout(MAGIC_TIMEOUT);
        var originalMochaRun = mocha.run;
        mocha.run = function (fn) {
            runnerBackChannel.addEventListener("message", function (event) {
                var message = event.data;
                if (message && message.type === "mocha-run") {
                    applyMochaOptions(mocha, message.mochaOptions || {});
                    originalMochaRun.call(mocha, function (failures) {
                        runnerBackChannel.postMessage({
                            type: "mocha-finished"
                        });
                        if (fn) {
                            fn(failures);
                        }
                    });
                }
            });
            runnerBackChannel.postMessage({
                type: "mocha-ready"
            });
            return undefined;
        };
    }
    /**
     * Initialize Mocha Webdriver Browser side.
     *
     * Checks `window.location.search` for specific `RemoteRunnerOptions` and if
     * `useMochaWebDriverRunner` flag is detected applies them to default `mocha` instance.
     */
    function initializeMochaWebDriverClient() {
        if (typeof window !== "undefined") {
            var queryString = window.location.search;
            if (!queryString) {
                return;
            }
            var parsed = lib.parse(queryString.substr(1));
            if (!parsed.useMochaWebDriverRunner) {
                return;
            }
            var mochaOptions = {};
            if (typeof parsed.timeout === "string") {
                mochaOptions.timeout = parseInt(parsed.timeout, 10);
            }
            if (typeof parsed.grep === "string") {
                mochaOptions.grep = parsed.grep;
            }
            if (typeof parsed.checkLeaks === "string") {
                mochaOptions.checkLeaks = parsed.checkLeaks !== "false";
            }
            if (typeof parsed.globals === "string") {
                mochaOptions.globals = String(parsed.globals)
                    .split(",")
                    .filter(function (s) { return s.length > 0; });
            }
            if (typeof parsed.captureConsoleLog === "string") {
                mochaOptions.captureConsoleLog = parsed.captureConsoleLog !== "false";
            }
            if (typeof parsed.captureConsoleLog === "string") {
                mochaOptions.captureConsoleLog = parsed.captureConsoleLog !== "";
            }
            if (typeof parsed.globalsToSave === "string") {
                mochaOptions.globalsToSave = String(parsed.globalsToSave)
                    .split(",")
                    .filter(function (s) { return s.length > 0; });
            }
            exports.queryStringRunnerOptions = mochaOptions;
        }
        if (typeof mocha !== "undefined") {
            addMochaSource(mocha);
        }
    }
    /**
     * @deprecated use [[addMochaSource]]
     */
    var install = addMochaSource;

    function runRemoteMochaTest(messagePort, options) {
        return new Promise(function (resolve, reject) {
            var result = {
                success: false,
                dumpedGlobals: {}
            };
            var captureConsoleLog = options.captureConsoleLog !== false;
            var reporterConstructor = getReporterConstructor(options);
            var synchronizer = createMochaStateSynchronizer();
            var runner;
            var reporter;
            var started = false;
            function processRunnerEvent(event) {
                if (event.type === "start") {
                    runner = new mocha$1.Runner(event.suite, options.delay === true);
                    runner.stats = {
                        suites: 0,
                        tests: 0,
                        passes: 0,
                        pending: 0,
                        failures: 0
                    };
                    reporter = new reporterConstructor(runner, options);
                    runner.emit("start");
                    started = true;
                }
                else if (event.type === "suite") {
                    runner.emit("suite", event.suite);
                }
                else if (event.type === "suite end") {
                    runner.emit("suite end", event.suite);
                }
                else if (event.type === "test") {
                    runner.emit("test", event.test);
                }
                else if (event.type === "test end") {
                    runner.emit("test end", event.test);
                }
                else if (event.type === "pass") {
                    runner.emit("pass", event.test);
                }
                else if (event.type === "fail") {
                    runner.emit("fail", event.test, event.err);
                }
                else if (event.type === "end") {
                    Object.assign(runner.stats, event.stats || {});
                    runner.emit("end");
                    end(event.failures || 0);
                }
                else if (event.type === "pending") {
                    runner.emit("pending", event.test);
                }
                else {
                    console.error("#runRemoteMochaTest: invalid event received from page", event.type || event);
                }
            }
            function onMessage(event) {
                var message = event.data;
                if (!message) {
                    console.log("#runRemoteMochaTest: received empty event");
                }
                switch (message.type) {
                    case "mocha-ready":
                        if (options.clientWaitsForOptions !== false) {
                            messagePort.postMessage({
                                type: "mocha-run",
                                mochaOptions: {
                                    grep: options.grep,
                                    captureConsoleLog: captureConsoleLog,
                                    timeout: options.timeout,
                                    globalsToSave: options.globalsToSave
                                }
                            });
                        }
                        break;
                    case "log":
                        if (!captureConsoleLog) {
                            return;
                        }
                        var args = ["[browser] " + message.level + ":"].concat(treesync.decodeMessage(message.args));
                        console[message.level].apply(console, args);
                        break;
                    case "var-dump":
                        var value = treesync.decodeMessage(message.value);
                        result.dumpedGlobals[message.name] = value;
                        break;
                    case "err-unhandled-exception":
                        {
                            console.error(message.message);
                            var error = treesync.decodeMessage(message.error);
                            if (error) {
                                console.error(error);
                            }
                        }
                        break;
                    case "mocha-runner-event":
                        processRunnerEvent(synchronizer.decodePacket(message.event));
                        break;
                    case "err-aborted":
                        {
                            var error = treesync.decodeMessage(message.error);
                            if (error) {
                                console.error(error);
                            }
                            cleanup();
                            reject(new Error(message.message));
                        }
                        break;
                }
            }
            function onErrorEvent(errorEvent) {
                var error = errorEvent.error || "missing error information";
                console.error("[browser] Unhandled exception: " + error, error);
                if (!started) {
                    reject(new Error("#runRemoteMochaTest: Unhandled exeption in remote context before test start: " + error));
                }
            }
            function start() {
                messagePort.addEventListener("message", onMessage);
                messagePort.addEventListener("error", onErrorEvent);
            }
            function cleanup() {
                messagePort.removeEventListener("message", onMessage);
                messagePort.removeEventListener("error", onErrorEvent);
            }
            function end(failures) {
                cleanup();
                // If reporter has 'done', then we shall call it (mochawesome relies on this).
                var reporterDone = reporter && reporter.done;
                if (typeof reporterDone === "function") {
                    reporterDone.call(reporter, failures, function () {
                        result.success = failures === 0;
                        resolve(result);
                    });
                }
                else {
                    result.success = failures === 0;
                    resolve(result);
                }
            }
            start();
        });
    }
    function getReporterConstructor(options) {
        var reporterDef = options.reporter || "spec";
        if (typeof reporterDef === "string") {
            var mochaBuiltinReporters = mocha$1.reporters;
            var builtinReporter = mochaBuiltinReporters[reporterDef];
            if (typeof builtinReporter === "function") {
                return builtinReporter;
            }
            var customReporter = require(reporterDef);
            if (typeof customReporter === "function") {
                return customReporter;
            }
        }
        if (typeof reporterDef === "function") {
            return reporterDef;
        }
        else {
            throw new Error("unknown reporter: " + reporterDef);
        }
    }

    /**
     * Adds Web Worker instance which will send test events, when ran.
     *
     * Worker instance, must run tests using mocha instrumented by [[addMochaSource]].
     *
     * All test events from mocha running in worker will be forwarded to [[runRemoteMochaTest]]
     * through [[BrowserMessagePort]]
     * Example:
     *
     * const testsWorker = new Worker('./tests-worker.js);
     * MochaWebdriverClient.addWorkerSource(testsWorker);
     */
    function addWorkerSource(worker) {
        runnerBackChannel.addEventListener("message", function (event) {
            var message = event.data;
            if (message && message.type === "mocha-run") {
                worker.postMessage(message);
            }
        });
        var firstMessage = true;
        worker.addEventListener("message", function (event) {
            if (firstMessage && exports.queryStringRunnerOptions !== undefined) {
                worker.postMessage({
                    type: "mocha-run",
                    mochaOptions: exports.queryStringRunnerOptions
                });
                firstMessage = false;
            }
            var message = event.data;
            runnerBackChannel.postMessage(message);
        });
        worker.addEventListener("error", function (event) {
            runnerBackChannel.postMessage({
                type: "err-unhandled-exception",
                message: "Unhandled error in Worker context.",
                error: treesync.buildMessage(event.error || event.message)
            });
        });
        if (exports.queryStringRunnerOptions === undefined) {
            runRemoteMochaTest(worker, {
                reporter: "html",
                captureConsoleLog: false,
                clientWaitsForOptions: true
            });
        }
    }

    function workerCode() {
        var MAGIC_TIMEOUT = 312345678;
        var DEFAULT_BOOTSTRAP_SCRIPTS = [
            "../node_modules/mocha/mocha.js",
            "../node_modules/mocha-webdriver-runner/dist/mocha-webdriver-client.js"
        ];
        function initialize(env) {
            var baseUrl = env.baseUrl || "";
            var bootstrapScripts = env.bootstrapScripts || DEFAULT_BOOTSTRAP_SCRIPTS;
            bootstrapScripts.forEach(function (scriptUrl) {
                self.importScripts(baseUrl + scriptUrl);
            });
            if (mocha === undefined) {
                self.postMessage({
                    type: "err-aborted",
                    message: "global object 'mocha' not available after bootstrap"
                });
            }
            if (MochaWebdriverClient === undefined) {
                self.postMessage({
                    type: "err-aborted",
                    message: "global object 'MochaWebdriverClient' not available after bootstrap"
                });
            }
            MochaWebdriverClient.installGlobalErrorHandlers();
            mocha.setup({
                ui: "bdd",
                reporter: MochaWebdriverClient.Reporter
            });
            mocha.timeout(MAGIC_TIMEOUT);
            var tests = env.tests || [];
            tests.forEach(function (testUrl) {
                self.importScripts(baseUrl + testUrl);
            });
            mocha.checkLeaks();
            mocha.run(function () {
                self.postMessage({ type: "mocha-finished" });
            });
        }
        var onMessage = function (event) {
            var message = event.data;
            try {
                if (message.type === "boostrap-worker") {
                    initialize(message);
                    self.removeEventListener('message', onMessage);
                }
                else {
                    console.log("unknown message received", message);
                }
            }
            catch (error) {
                self.postMessage({
                    type: "err-unhandled-exception",
                    message: "[worker] " + error.message,
                    // manually serialized error
                    error: {
                        root: {
                            type: 'error',
                            value: {
                                message: error.message,
                                stack: error.stack
                            }
                        },
                        objects: {}
                    }
                });
            }
        };
        self.addEventListener('message', onMessage);
        self.postMessage({ type: "worker-ready-for-bootstrap" });
    }
    /**
     * Run `tests` under Mocha in WebWorker.
     *
     * All test events are forwarded using [[emitPageEvent]] to node driver.
     *
     * @param options urls of test scripts or [[WorkerTestAutoOptions]].
     */
    function runWorkerTestsAuto(options) {
        var actualOptions = Array.isArray(options)
            ? {
                tests: options
            }
            : options;
        installGlobalErrorHandlers();
        installConsoleLogForwarder();
        return new Promise(function (resolve, reject) {
            var workerScript = "\n            " + workerCode + "\n            workerCode();\n        ";
            var workerScriptBlob = new Blob([workerScript], { type: "application/javascript" });
            var workerScriptUrl = URL.createObjectURL(workerScriptBlob);
            var worker = new Worker(workerScriptUrl);
            var firstMessageReceived = false;
            var bootstraped = false;
            function end() {
                worker.terminate();
            }
            function emitCommandToWorker(command) {
                worker.postMessage(command);
            }
            var onWorkerError = function (event) {
                if (!firstMessageReceived || !bootstraped) {
                    worker.terminate();
                    var message = firstMessageReceived
                        ? "unable to boostrap Worker"
                        : "unable to start Worker";
                    runnerBackChannel.postMessage({
                        type: "err-aborted",
                        message: message,
                        error: treesync.buildMessage(event.error || event.message)
                    });
                    reject(new Error(message));
                }
                else {
                    runnerBackChannel.postMessage({
                        type: "err-unhandled-exception",
                        message: "Unhandled error in Worker context.",
                        error: treesync.buildMessage(event.error || event.message)
                    });
                }
            };
            var onWorkerMessage = function (event) {
                if (!firstMessageReceived) {
                    firstMessageReceived = true;
                }
                var message = event.data;
                //
                // TODO:
                //   This protocol (worker-ready-for-bootstrap&boostrap-worker) can be generalized and
                //   used "driver->browser" auto scheme too so client doesn't have to create html and
                //   `mocha-webdriver-runner` can be serve files too!.
                //
                if (message.type === "worker-ready-for-bootstrap") {
                    emitCommandToWorker({
                        type: "boostrap-worker",
                        baseUrl: baseUrl(document.baseURI),
                        bootstrapScripts: actualOptions.bootstrapScripts,
                        tests: actualOptions.tests
                    });
                    worker.removeEventListener("error", onWorkerError);
                    worker.removeEventListener("message", onWorkerMessage);
                    // pass control to normal worker handler
                    addWorkerSource(worker);
                }
                else if (message.type === "mocha-finished") {
                    end();
                    resolve();
                }
            };
            worker.addEventListener("error", onWorkerError);
            worker.addEventListener("message", onWorkerMessage);
        });
    }
    function baseUrl(url) {
        var idx = url.lastIndexOf("/");
        if (idx === -1) {
            return "./";
        }
        else {
            return url.substring(0, idx + 1);
        }
    }

    initializeMochaWebDriverClient();

    exports.MAGIC_TIMEOUT = MAGIC_TIMEOUT;
    exports.MochaRemoteReporter = MochaRemoteReporter;
    exports.Reporter = MochaRemoteReporter;
    exports.addMochaSource = addMochaSource;
    exports.addWorkerSource = addWorkerSource;
    exports.applyMochaOptions = applyMochaOptions;
    exports.delayMochaRun = delayMochaRun;
    exports.inWebWorkerContext = inWebWorkerContext;
    exports.initializeMochaWebDriverClient = initializeMochaWebDriverClient;
    exports.install = install;
    exports.installConsoleLogForwarder = installConsoleLogForwarder;
    exports.installGlobalErrorHandlers = installGlobalErrorHandlers;
    exports.overrideDefaultMagicTimeout = overrideDefaultMagicTimeout;
    exports.runRemoteMochaTest = runRemoteMochaTest;
    exports.runWorkerTestsAuto = runWorkerTestsAuto;
    exports.runnerBackChannel = runnerBackChannel;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
