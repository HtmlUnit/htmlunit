#!/usr/bin/env node
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var commander = require("commander");
var fs = require("fs");
var path = require("path");
var lodash_1 = require("lodash");
var MochaWebDriverRunner_1 = require("./MochaWebDriverRunner");
var DEFAULT_CONFIG_FILE = ".mocha-webdriver-runner.json";
function readDefaultCliOptions() {
    var optionsRaw;
    if (!fs.existsSync(DEFAULT_CONFIG_FILE)) {
        return {};
    }
    try {
        optionsRaw = fs.readFileSync(DEFAULT_CONFIG_FILE, "utf-8");
    }
    catch (error) {
        throw new Error("unable to read config from '" + DEFAULT_CONFIG_FILE + "': " + error);
    }
    return JSON.parse(optionsRaw);
}
var DEFAULT_CLI_OPTIONS = {
    captureConsoleLog: true,
    capabilities: {},
    timeout: 2000,
    reporter: "spec"
};
var programOptions = lodash_1.cloneDeep(DEFAULT_CLI_OPTIONS);
var useDefaultConfigFile = true;
function consumeOptionsFileOption(name) {
    useDefaultConfigFile = false;
    var fromFile = JSON.parse(fs.readFileSync(name, "utf-8"));
    lodash_1.merge(programOptions, fromFile);
    return name;
}
function numberOptionConsumer(name) {
    return function (value, current) {
        var intValue = parseInt(value, 10);
        lodash_1.set(programOptions, name, intValue);
        return name;
    };
}
function stringOptionConsumer(name) {
    return function (value, current) {
        lodash_1.set(programOptions, name, value);
        return value;
    };
}
function booleanOptionConsumer(name) {
    return function (value, current) {
        var normalized = value.toLocaleLowerCase();
        var enabled = normalized === "yes" || normalized === "1" || normalized === "true";
        lodash_1.set(programOptions, name, enabled);
        return value;
    };
}
function consumeReporterOptions(optionsString) {
    if (!optionsString) {
        return optionsString;
    }
    var result = {};
    optionsString.split(",").forEach(function (opt) {
        var parsed = opt.split("=");
        if (parsed.length > 2 || parsed.length === 0) {
            throw new Error("invalid reporter option '" + opt + "'");
        }
        else if (parsed.length === 2) {
            result[parsed[0]] = parsed[1];
        }
        else {
            result[parsed[0]] = true;
        }
    });
    programOptions.reporterOptions = result;
    return optionsString;
}
function collectCapabilities(val, capabilities) {
    if (!val) {
        throw new Error("capability cannot be empty");
    }
    var dividerIndex = val.indexOf("=");
    var value;
    var key;
    if (dividerIndex === -1) {
        key = val;
        value = true;
    }
    else {
        key = val.substr(0, dividerIndex);
        value = val.substr(dividerIndex + 1);
    }
    if (typeof value === "string") {
        if (value.startsWith("{") || value.startsWith('"') || value.startsWith("[")) {
            value = JSON.parse(value);
        }
    }
    lodash_1.set(programOptions.capabilities, key, value);
}
function collectGlobalsToSave(val) {
    if (!val) {
        throw new Error("global name cannot be empty");
    }
    var globalName;
    var outputFileName;
    var dividerIndex = val.indexOf(":");
    if (dividerIndex === -1) {
        globalName = val;
        outputFileName = val + ".json";
    }
    else {
        globalName = val.substr(0, dividerIndex);
        outputFileName = val.substr(dividerIndex + 1);
    }
    if (!programOptions.globalsToSave) {
        programOptions.globalsToSave = {};
    }
    programOptions.globalsToSave[globalName] = outputFileName;
}
var globals = [];
function collectGlobals(val) {
    if (!val) {
        throw new Error("global name cannot be empty");
    }
    globals.push.apply(globals, __spread(val.split(",")));
    return val;
}
function looksLikeUrl(val) {
    return val.startsWith("http:") || val.startsWith("https:") || val.startsWith("file:");
}
function createLocalFileUrl(testPagePath) {
    var absoluteTestPagePath = path.resolve(process.cwd(), testPagePath);
    return "file://" + absoluteTestPagePath;
}
var version = JSON.parse(fs.readFileSync(path.join(__dirname, "..", "package.json"), "utf8")).version;
var program = new commander.Command();
program
    .usage("[options] URL")
    .option("-c, --config <FILE>", "config file", consumeOptionsFileOption, DEFAULT_CONFIG_FILE)
    .option("-C, --capability <name[=value]>", "required browser capability", collectCapabilities)
    .option("-O, --reporter-options <k=v,k2=v2,...>", "reporter-specific options", consumeReporterOptions())
    .option("-R, --reporter <name>", "specify the reporter to use", stringOptionConsumer("reporter"), DEFAULT_CLI_OPTIONS.reporter)
    .option("-t, --timeout <ms>", "set test-case timeout in milliseconds", numberOptionConsumer("timeout"), DEFAULT_CLI_OPTIONS.timeout)
    .option("--check-leaks <boolean>", "Check for global variable leaks")
    .option("--globals <name1,name2...>", "list of allowed global variables", collectGlobals)
    .option("-S, --save <globalName[:fileName]>", "save global `name` as JSON file", collectGlobalsToSave)
    .option("-L, --capture-console-log <boolean>", "whether to capture console.log in browser context", booleanOptionConsumer("captureConsoleLog"))
    .option("-g, --grep <pattern>", "only run tests/suites that match pattern", stringOptionConsumer("grep"))
    .version(version);
var shortcuts = {
    chrome: {
        doc: "use Chrome",
        capabilities: {
            browserName: "chrome"
        }
    },
    "headless-chrome": {
        doc: "use headless Chrome",
        capabilities: {
            browserName: "chrome",
            "goog:chromeOptions": {
                args: ["--headless"]
            }
        }
    },
    firefox: {
        doc: "use Firefox",
        capabilities: {
            browserName: "firefox"
        }
    },
    "headless-firefox": {
        doc: "use headless Firefox",
        capabilities: {
            browserName: "firefox",
            "moz:firefoxOptions": {
                args: ["-headless"]
            }
        }
    },
    safari: {
        doc: "use Safari",
        capabilities: {
            browserName: "safari"
        }
    },
    edge: {
        doc: "use Edge",
        capabilities: {
            browserName: "MicrosoftEdge"
        }
    }
};
var _loop_1 = function (name_1) {
    var entry = shortcuts[name_1];
    program.option("--" + name_1, entry.doc, function () {
        console.log("XX", name_1);
        lodash_1.merge(programOptions.capabilities, entry.capabilities);
    });
};
for (var name_1 in shortcuts) {
    _loop_1(name_1);
}
program.parse(process.argv);
console.log("");
if (useDefaultConfigFile) {
    programOptions = lodash_1.merge({}, DEFAULT_CLI_OPTIONS, readDefaultCliOptions, programOptions);
}
var args = program.args;
if (args.length < 1) {
    program.outputHelp();
    throw new Error("mocha-webdriver-runer: URL needed");
}
var mainScript = program.args.shift();
var url = looksLikeUrl(mainScript) ? mainScript : createLocalFileUrl(mainScript);
if (process.env.SELENIUM_REMOTE_URL && url.startsWith("file:")) {
    console.warn("mocha-webdriver-runner: warning: remote selenium nodes usually don't work with file:// urls");
}
var options = {
    reporter: programOptions.reporter,
    reporterOptions: programOptions.reporterOptions,
    grep: programOptions.grep,
    checkLeaks: programOptions.checkLeaks,
    globals: programOptions.globals,
    timeout: programOptions.timeout,
    globalsToSave: programOptions.globalsToSave && Object.keys(programOptions.globalsToSave),
    captureConsoleLog: programOptions.captureConsoleLog
};
MochaWebDriverRunner_1.runMochaWebDriverTest(programOptions.capabilities, url, options)
    .then(function (result) {
    for (var varName in result.dumpedGlobals) {
        var varValue = result.dumpedGlobals[varName];
        var fileName = programOptions.globalsToSave[varName];
        console.log("mocha-webdriver-runner: saving " + varName + " dump in " + fileName);
        fs.mkdirSync(path.dirname(fileName), { recursive: true });
        fs.writeFileSync(fileName, JSON.stringify(varValue), "utf-8");
    }
    if (result.success) {
        process.exit(0);
    }
    else {
        process.exit(1);
    }
})
    .catch(function (error) {
    console.error("mocha-webdriver-runner: unexpected error: " + error);
    console.error(error);
    process.exit(1);
});
