<?xml version="1.0"?>
<document xmlns="http://maven.apache.org/XDOC/2.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="https://maven.apache.org/XDOC/2.0 https://maven.apache.org/xsd/xdoc-2.0.xsd">

    <properties>
        <title>Details about HtmlUnit</title>
        <author>RBRi</author>
    </properties>

    <body>
        <section name="Content" id="content">
            <macro name="toc">
            </macro>
        </section>

        <section name="Request headers" id="request_headers">
            <p>
                HtmlUnit mimics the browser as close as possible, of course this includes the sent request headers also.
                But you can change this if needed at three levels; the request level, the client level and the BrowserVersion level.<br/>
            </p>

            <subsection name="BrowserVersion level">
            <p>
              To change the request header at the BrowserVersion level you have to create your own customized browser version using
              the BrowserVersionBuilder.
            </p>
            <source><![CDATA[
final BrowserVersion browser =
    new BrowserVersion.BrowserVersionBuilder(BrowserVersion.FIREFOX)
          .setAcceptLanguageHeader("de-CH")
          .build();

final WebClient webClient = new WebClient(browser);
....
]]></source>
            <p>
            There are many methods available to customize basic browser behavior like
            <ul>
              <li>setApplicationCodeName(String)</li>
              <li>setApplicationMinorVersion(String)</li>
              <li>setApplicationName(String)</li>
              <li>setApplicationVersion(String)</li>
              <li>setBuildId(String)</li>
              <li>setPlatform(String)</li>
              <li>setSystemLanguage(String)</li>
              <li>setSystemTimezone(TimeZone)</li>
              <li>setUserAgent(String)</li>
              <li>setVendor(String)<br/></li>

              <li>setUserLanguage(String)</li>
              <li>setBrowserLanguage(String)<br/></li>

              <li>setAcceptEncodingHeader(String)</li>
              <li>setAcceptLanguageHeader(String)</li>
              <li>setCssAcceptHeader(String)</li>
              <li>setHtmlAcceptHeader(String)</li>
              <li>setImgAcceptHeader(String)</li>
              <li>setScriptAcceptHeader(String)</li>
              <li>setXmlHttpRequestAcceptHeader(String)</li>
            </ul>
            </p>
            </subsection>

            <subsection name="WebClient level">
            <p>
                To change the request header at the client level use WebClient.addRequestHeader(). You are able to
                add additional headers to every request made by this client or overwrite the default ones.<br/>
                Example: add an addition header to every client request
            </p>
            <source><![CDATA[client.addRequestHeader("from htmlunit", "yes");]]></source>
            <p>
                Example: replace the default accept-language header for all request made by this client.
            </p>
            <source><![CDATA[client.addRequestHeader(HttpHeader.ACCEPT_LANGUAGE, "fr");]]></source>
            <p>
                Example: replace the default accept-language header for all request made by this client.
            </p>
            <source><![CDATA[client.addRequestHeader(HttpHeader.ACCEPT_LANGUAGE, fromClient);]]></source>
            <p>
                Example: replace the default accept-language header for all request made by this client.
            </p>
            <source><![CDATA[client.addRequestHeader(HttpHeader.ACCEPT_LANGUAGE, fromClient);]]></source>
            </subsection>

            <subsection name="Request level">
            <p>
                It is also possible to add/overwrite a request header for a dedicated request.
                Example:
            </p>
            <source><![CDATA[
WebRequest wr = new WebRequest(URL_FIRST);
wr.setAdditionalHeader("from htmlunit", "yes");
....
client .getPage(wr);
]]></source>
             </subsection>
        </section>

        <section name="Animations based on Window.requestAnimationFrame()"  id="animations">
            <p>
                All browsers supporded by HtmlUnit are able to do animations based on the
                <a href='https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame'>Window.requestAnimationFrame() API</a>.
                A typical example for this is <a href='https://www.chartjs.org/'>Chart.js</a>.
                This kind of animation support is not triggered automatically because HtmlUnit is headless.
                The javascript part of the API is implemented but the user of the HtmlUnit library has to force the triggering of the callback(s).
            </p>
            <p>
                Example:
            </p>
            <source><![CDATA[
try (final WebClient webClient = new WebClient(BrowserVersion.FIREFOX)) {
    HtmlPage page = webClient.getPage(uri);
    webClient.waitForBackgroundJavaScript(1_000);

    // page is loaded and async js done

    // we now processing the animation
    Window window = page.getEnclosingWindow().getScriptableObject();
    int i = 0; // to be able to limit the animation cycles
    do {
        i++;

        // force one animation cycle
        // this invokes all the animation callbacks registered for this
        // window (by calling requestAnimationFrame(Object)) once.
        int pendingFrames = window.animateAnimationsFrames();
    } while (pendingFrames > 0 && i < 200);
}
]]></source>
            <p>
                Based on this you have to full control over the animation, you can skip all, but you are also
                check the current page state after each single animation step.
            </p>
        </section>

        <section name="Attachments" id="attachments">
            <p>
                Normally pages are loaded inline: clicking on
                a link, for example, loads the linked page in the current window. Attached pages are different
                in that they are intended to be loaded outside of this flow: clicking on a link prompts the
                user to either save the linked page, or open it outside of the current window, but does not
                load the page in the current window.
            </p>
            <p>
                HtmlUnit complies with the semantics described above when an <tt>AttachmentHandler</tt> has
                been registered with the org.htmlunit.WebClient via
                org.htmlunit.WebClient#setAttachmentHandler(AttachmentHandler). When
                no attachment handler has been registered with the <tt>WebClient</tt>, the semantics described
                above to not apply, and attachments are loaded inline. By default, <tt>AttachmentHandler</tt>s
                are not registered with new <tt>WebClient</tt> instances.
            </p>
        </section>

        <section name="Content blocking" id="content_blocking">
            <p>
                Out of the box HtmlUnit does not include any content blocking mechanism. But there are several
                options to include your own.<br/>
            </p>
            <subsection name="Blocking based on the request (URL)">
                <p>
                    This simple form of content blocking works based on the requested url. Usually you have
                    to use a list of bolked url's or some url patterns to detect the blocked url. In case
                    the url is blocked the request is not sent to the server; instead a simple page is returned.
                </p>
                <p>
                    With HtmlUnit you can implement this using a WebConnectionWrapper.
            <source><![CDATA[
    try (WebClient webClient = new WebClient()) {
        webClient.getOptions().setThrowExceptionOnScriptError(false);
        // set more options

        // create a WebConnectionWrapper with an (subclassed) getResponse() impl
        new WebConnectionWrapper(webClient) {

            @Override
            public WebResponse getResponse(final WebRequest request) throws IOException {
                final URL url = request.getUrl();
                // check the request url
                // if is allowed simple call super.

                if (!isBlocked(url)) {
                    return super.getResponse(request);
                }

                // construct alternative response
                final String content = "<html><html>";
                final WebResponseData data = new WebResponseData(content.getBytes(Charsets.UTF_8),
                        200, "blocked", Collections.emptyList());
                final WebResponse blocked = new WebResponse(data, request, 0L);
                // if you like to check later on for blocked responses
                blocked.markAsBlocked("Blocked URL: '" + url.toExternalForm() + "'");
                return blocked;
            }

            private boolean isBlocked(final URL url) {
                return true;
            }
        };

        // use the client as usual
        final HtmlPage page = webClient.getPage(url);
    }
            ]]></source>
                </p>
            </subsection>

            <subsection name="Blocking based on the response (headers)">
                <p>requires HtmlUnit 3.4.0 or later</p>
                <p>
                    For blocking based on the response a more sophisticated approche is needed.
                    The following sample code shows blocking base on the content length header. Using
                    this you are able to check the header of the respons and stop downloading the whole
                    response directly. This might be helpfull to improve the speed of some test cases.
                </p>
                <p>
                    For the implementation we have to deal with the real web connection to be able to
                    access the headers before the whole content is downloaded and also to abort the
                    download of the body itself. Therefore we have to replace the WebConnection with
                    our own subclass of HttpWebConnection.
            <source><![CDATA[
    try (WebClient webClient = new WebClient()) {
        webClient.getOptions().setThrowExceptionOnScriptError(false);
        // set more options
  
        // use our own sublcass of HttpWebConnection
        webClient.setWebConnection(new HttpWebConnection(webClient) {
            @Override
            protected WebResponse downloadResponse(final HttpUriRequest httpMethod,
                    final WebRequest webRequest, final HttpResponse httpResponse,
                    final long startTime) throws IOException {
  
                // check content length header
                final int contentLenght = Integer.parseInt(
                        httpResponse.getFirstHeader(HttpHeader.CONTENT_LENGTH).getValue());
  
                // if not too big - done
                if (contentLenght < 1_000) {
                    return super.downloadResponse(httpMethod, webRequest, httpResponse, startTime);
                }
  
                // abort downloading of the content
                httpMethod.abort();
  
                // construct alternative response
                final String content = "<html><html>";
                final WebResponseData data = new WebResponseData(content.getBytes(Charsets.UTF_8),
                        200, "blocked", Collections.emptyList());
                final WebResponse blocked = new WebResponse(data, webRequest, 0L);
                // if you like to check later on for blocked responses
                blocked.markAsBlocked("Blocked URL: '" + url.toExternalForm()
                            + "' content length: " + contentLenght);
                return blocked;
            }
        });
  
        // use the client as usual
        final HtmlPage page = webClient.getPage(url);
    }
            ]]></source>
                </p>
            </subsection>
        </section>

        <section name="Multithreading/Threads Pooling" id="multithreading">
            <p>
                HtmlUnit uses an Executor backed by a CachedThreadPool for thread handling. This should work
                fine for common cases. The CachedThreadPool is in use since 2.54.0 to be able to support scenarios using
                many treads e.g. because of many WebSockets.
            </p>
            <p>
                Starting with 2.45.0 you can change this by using WebClient.setExecutor(ExecutorService). It might be
                a good idea to also implement some thread naming to distinguish Threads used by HtmlUnit from the rest.
            </p>
        </section>
    </body>
</document>
